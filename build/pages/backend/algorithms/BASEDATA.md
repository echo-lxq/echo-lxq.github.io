# 基础数据类型 #

## 1.队列 跟 栈 ##
**1.区别**<br>

- 操作名称不同入队、出队、进栈、出栈<br>
- 操作方式不容队列队尾入队，队头出队。栈进栈出栈都是在栈顶进行<br>
- 操作的方法不同队列是先进先出(FIFO)，即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾(不能中间插入),每次离开的成员总是队列头上(不允许中途离队)。而栈为后进先出(LIFO),即每次删除(出栈pop)的总是当前栈最新的元素，即最后插入（进栈push）的元素，而最先插入的被放在栈的底部，最后才能删除。

**2.栈的应用**<br>

**顺序栈**

    #define MAXSIZE (100) //栈的最大存储数据量
    
    typedef struct STACK
    {
    	int data[MAXSIZE]; //用于存储数据的数组
    	int top; //栈顶指针
    }SqStack;
顺序栈的**进栈**操作：

- 检查是否满栈，满栈退出并返回错误
- 栈顶指针top向上移动一位，将要插入的数据赋给栈顶

顺序栈的**出栈**操作：

- 检查是否为空栈，若是则退出并返回错误；
- 将栈顶数据赋给*data(函数参数的传递必须要用到指针的，c++最好使用引用)，栈顶指针向下移动一位。

**链栈**

线性表有顺序存储和链式存储结构，栈是一种特殊的线性表，那么也有链式存储结构，简称链栈。

将链表的头指针作为栈的栈顶指针，因为有栈顶指针，就不需要链表的头结点了。
    
    typedef struct StackNode //结点
    {
    	int data;
    	struct StackNode *next;
    }StackNode; 
    
    typedef struct LinkStack //栈顶指针和结点数
    {
    	StackNode *top;
    	int count;
    }LinkStack;

链栈**进栈**操作：

- 申请一个新结点，储存进栈数据；
- 将新结点插入到链表的最前端，使其next指向原先的top结点，最后使top指向新结点；

链栈**出栈**操作：

- 检查是否为空栈，若是返回错误，否则将栈顶指针指向的数据赋给*data；
- 删除栈顶结点：定义一个指针p，指向栈顶结点，将栈顶指针top指向下一个结点，删除栈顶结点。

顺序栈的链栈的时间复杂度是一样的，都是O(1)，如果栈内元素数量变化小且可控，可以使用顺序栈，链栈因为每个结点都有指针域，增加了一定内存的开销；如果栈内的元素数量不可控，最好使用链表，根据实际需求变化长度，不会造成大量空间浪费。

**应用**

- 大多数的编译器递归操作基于栈实现的
- 四则运算表达式：从左到右遍历中缀表达式的每个数组跟符号，若是数字就输出成为后缀表达式（有名逆波兰表达式，所有符号都要在运算附后的后面出现）的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并当前符号进栈，移植到最终输出后缀表达式为止；
- 中缀到后缀的转换

**3.队列的应用**




## 2.链表 ##

链表是一种物理存储结构上非连续、非顺序的储存结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。