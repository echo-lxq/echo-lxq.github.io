{"./":{"url":"./","title":"gitbook使用介绍","keywords":"","body":"gitbook-template 环境安装 1.nodejs安装 nodejs官方下载地址：https://nodejs.org/zh-cn/ 2.gitbook安装 npm install gitbook-cli -g 安装成功后执行 gitbook -V 报错与解决方案 http://wlphp.com/m/?post=369 gitbook模板使用 使用 gitbook模板，克隆到本地执行 npm install 安装插件即可使用（之前需在本地安装gitbook环境） npm run serve -- 启动web服务，默认端口4000。 npm run build -- 打包部署 目录 assets -- 资源文件目录 pages -- 书章节存放目录 books.js -- gitbook配置文件目录 .bookignore -- gitbook打包忽略文件目录 SUMMARY.md -- 目录文件 插件列表 插件使用如下命令安装使用 npm install gitbook-plugin-插件名 模块名称 功能描述 accordion 手风琴折叠模块 ace 代码 ACE 显示 advanced-emoji 显示 emoji 表情 alerts 告警级别信息提示 anchor-navigation-ex 悬浮目录和回到顶部 ancre-navigation 悬浮目录和回到顶部 auto-scroll-table 表格滚动条 back-to-top-button 当页面超过一屏幕时，会显示一个 回到顶部按钮 change_girls 可自动切换的背景 click-reveal 默认隐藏，点击可显示 code 代码添加行号&复制按钮 copy-code-button 代码复制按钮 custom-favicon 修改网页标题图标 favicon chapter-fold 导航目录默认折叠 Chart 绘制图形 donate 贡献 disqus 评论系统 emphasize 为文字加上底色 expandable-chapters 导航目录折叠扩展 expandable-chapters-small expandable-chapters-small edit-link 添加编辑按钮 favicon 显示网站图标 flexible-alerts flexible-alerts github 在右上角添加 github 图标 hide-element 可以隐藏不想看到的元素，比如导航栏中 Published by GitBook insert-logo 插入logo include-codeblock 包含或显示文件 include-csv 显示 CSV 文件内容 KaTex 数学公式支持 klipse klipse 嵌入类似IDE的功能 lightbox 单击查看图片 点击图片可显示，大小不变 lunr lunr local-video 视频 mermaid 流程图 Mermaid-gb3 流程图 Musicxml 乐谱渲染 page-copyright 页面页脚版权 page-toc-button 悬浮目录 page-top page-top.md page-treeview 生成页内目录 page-treeview-simle 生成页内目录精简版本 pageview-count 阅读量计数 popup 单击图片，在新页面查看大图 prism 语法高亮 PlantUML UML reward 赞赏组件 rss RSS 订阅 search 搜索 search-pro 高级搜索 search-plus search-plus sectionx.md sectionx [simple-page-toc(cat-article-content.md) plugins/simple-page-toc sharing-plus 分享当前页面 sidebar-style 会替换掉 Published by GitBook splitter 侧边栏宽度可调节 sitemap-general 自动生成 sitemap 文件 summary 自动生成 SUMMARY.md tbfed-pagefooter 页面添加页脚 tags tags todo todo Terminal Terminal 终端 Version-select 文档多版本 "},"pages/html/HTML.html":{"url":"pages/html/HTML.html","title":"前端","keywords":"","body":" 前端 "},"pages/html/REACT.html":{"url":"pages/html/REACT.html","title":"React","keywords":"","body":"一、react基本介绍 1.优点 ① 声明式设计 - 轻松描述应用 ② 高效- react通过对dom的模拟(虚拟dom)，最大限度地减少与DOM的交互  灵活- react可以与已知库或者框架很好地配合。 ③ 组件化 - 通过React构建组件，使得代码更容易得到复用，能够很好的应用在大项目中。 ④单项数据流 - React实现了单项响应的数据流从而简化扫了重复代码，这也是它为什么比传统数据绑定更简单； ⑤虚拟dom - 前端开发中 性能消耗最大的就是DOM操作。React把真是的DOM树转换成JavaScript对象树，也就是 Virtual DOM 。  JSX - 是JavaScript语法的扩展。 XML可扩展标记语言 跟 html超文本标记语言 区别 -- 都是标记语言 ， html预定义 xml 自定义的... 2.介绍 源于Facebook的内部项目，用来架设Instagram的网站；2013年5月开源。 react将界面分成了各个独立的小块，每一个块就是组件，这些组件之间可以组合、嵌套、就形成我们的页面。 关于react全家桶 1、react react的核心。 2、redux redux相当于一个数据库，可以当成一个本地的数据库使用，react-redux可以完成数据订阅，redux-thunk可以实现异步的action，redux-logger是redux的日志中间件。 3、react-router React Router 是专为 React 设计的路由解决方案。它利用HTML5 的history API，来操作浏览器的 session history (会话历史)。 React Router被拆分成四个包：react-router，react-router-dom，react-router-native和react-router-config。react-router提供核心的路由组件与函数。react-router-config用来配置静态路由（还在开发中），其余两个则提供了运行环境（浏览器与react-native）所需的特定组件。 进行网站（将会运行在浏览器环境中）构建，我们应当安装react-router-dom。因为react-router-dom已经暴露出react-router中暴露的对象与方法，因此你只需要安装并引用react-router-dom即可。 4、axios axios是基于Promise的用于浏览器和Node.js的http客户端。可以发送get、post等http请求，用来和服务器进行交互的。 5、antd Ant Degisn是个很好的React UI库，看起来跟我们熟知的bootstrap有点类似，从页面布局到按钮到文字提示泡应有尽有。 二、react安装 1.全局安装 create-react-app npm install -g create-react-app 2.创建一个项目 create-react-app your-app 3.不想全局安装可以使用npx npx create-react-app your-app 也可以实现相同效果 npx - 临时安装 安装之后这需要等待一段时间，这个过程实际上安装三个东西 react:react的顶级库 react-dom:因为react有很多的运行环境，比如app端的react-native,我们要在web端运行就使用react-dom react-scripts:包含运行和打包react应用程序的所有脚本及配置 PS. npm切换为淘宝镜像 或者 yarn切换到淘宝镜像 三、目录介绍 README.md -- 使用方法的文档 node_modules -- 所有的依赖安装的目录 package-lock.json -- 锁定安装的包的版本号保证团队的依赖能保证一致 package.json public -- 静态公共目录 src -- 开发用的源代码目录 PS.关于package.json与package-lock.json的区别 1.package-lock.json 存储node_modules下包的信息，包括版本号、下载地址等 作用：锁定安装时的包版本号，需要上传到git上，以保证其他人在install时候，大家的依赖版本相同。 2.package.json 包描述文件 作用：其实最有用的是dependencies选项，包含第三方包依赖信息 package-lock.json跟package.json的区别在于： \"dependencies\": { \"@types/node\": \"^8.0.33\", } 这里的^向上尖号是定义向后（新）兼容依赖，如果types/node版本是超过8.0.33，并且是在大版本（8）上相同，就允许下载最新的types/node包。同一个大版本不同版本号之间存在差异，导致依赖库包行为特征有时候不兼容。 而package-lock.json就只会下载8.0.33版本的。 npm5以前     npm5以前，没有package-lock.json这个文件。package.json文件会记录你项目中所需要的所有模块。当你执行npm install的时候，node会先从package.json文件中读取所有dependencies信息，然后根据dependencies中的信息与node_modules中的模块进行对比，没有的直接下载，已有的检查更新。     因为package.json只能锁定模块的大版本号（版本号的第一位），不能锁定后面的小版本，所以你每次重新npm install时候拉取的都是该大版本下面最新的版本。一般我们为了稳定性考虑我们不能随意升级依赖包，因为如果换包导致兼容性bug出现很难排查，这样很容易出现问题，所以package-lock.json就是来解决包锁定不升级问题的。另外，package.json文件只记录你通过npm install方式安装的模块信息，而这些模块所依赖的其他子模块的信息不会记录。 npm5以后     package-lock.json文件锁定所有模块的版本号，包括主模块和所有依赖子模块。当你执行npm install的时候，node从package.json文件读取模块名称，从package-lock.json文件中获取版本号，然后进行下载或者更新。     因此，正因为有了package-lock.json文件锁定版本号，所以当你执行npm install的时候，node不会自动更新package.json文件中的模块，必须用npm install packagename@x.x.x（指定版本号）来进行安装才会更新，package-lock.json文件中的版本号也会随着更新。 四、vscode 快速添加头注释 安装 koroFileHeader 配置 setting.json 在VS Code中，依次打开 “文件(File) → 首选项(Preferences) → 设置(Settings)”,然后搜索fileheader以打开setting.json文件 最后在setting.json中添加如下配置命令：（配置命令可自定义修改哈，详细配置见GitHub：koroFileHeader） // 头部注释 \"fileheader.customMade\": { //快捷键 ctrl+win+i \"Author\": \"Xminyang\", // 创建文件的作者 \"Date\": \"Do not edit\", // 文件创建时间(不变) \"LastEditors\": \"Xminyang\", // 文件最后编辑者 // 由于编辑文件就会变更最后编辑时间，多人协作中合并的时候会导致merge // 可以将时间颗粒度改为周、或者月，这样冲突就减少很多。搜索变更时间格式: dateFormat \"LastEditTime\": \"Do not edit\", // 文件最后编辑时间 // 输出相对路径，类似: /文件夹名称/src/index.js \"FilePath\": \"Do not edit\", // 文件在项目中的相对路径 自动更新 // 插件会自动将光标移动到Description选项中 方便输入 Description字段可以在specialOptions更改 \"Description\": \"\", // 介绍文件的作用、文件的入参、出参。 // custom_string_obkoro1~custom_string_obkoro100都可以输出自定义信息 // 可以设置多条自定义信息 设置个性签名、留下QQ、微信联系方式、输入空行等 \"custom_string_obkoro1\": \"\", // 版权声明 保留文件所有权利 自动替换年份 \"custom_string_obkoro1_copyright\": \"Copyright (c) ${now_year} by 用户/公司名, All Rights Reserved. \" }, // 函数注释 \"fileheader.cursorMode\": {//快捷键 ctrl+win+t \"description\": \"\", // 函数注释生成之后，光标移动到这里 \"param\": \"\", // param 开启函数参数自动提取 需要将光标放在函数行或者函数上方的空白行 \"return\": \"\", } 2、快捷键 添加文件头部注释：Ctrl+Win+i 添加函数注释：Ctrl+Win+t 五、开始第一个react应用 react开发需要引入多个依赖文件：react.js、react-dom.js，分别又有开发版本和生产版本，create-react-app里已经安装好。把通过CRA创建的工程目录清空，然后里面重新创建一个index.js写入以下代码： 知识： es6中引用模块import后面加上花括号{}和不加花括号的区别 import不使用花括号 不使用{}来引用模块的情况下，import模块时的命名是随意的，即如 下是那种引用命名都是正确的； 它总是会解析到A.js中默认的export default。 //A.js export default 42 . export const A = 52 . //B.js,B.js引用A.js import A from './A' import MyA from './A' import Something from './A' 2.import使用花括号{} 下面代码生效的前提是，只有在A.js中命名导出为A的export name 的代码 //B.js import { A } from './A' //正确，因为A.js中有命名为A的export import { myA } from './A' //错误！因为A.js中没有命名为myA的export import { Something } from './A' //错误！因为A.js中没有命名为Something的export .开始第一个react应用 //这部分在react17.x的版本适用 // //引入react 核心模块 // //从react的包当中引入了React，只要你要写React.js组件就必须引入React， // //因为react里有一种语法叫JSX,要写JSX就必须引入React // import React from \"react\"; // //ReactDom 可以帮助我们把React组件渲染到页面上去，没有其他作用了。它 // //是从react-dom中引入的 // // import ReactDOM from \"react-dom\"; //18.x版本更新页面渲染方式 import React from \"react\"; import ReactDOM from \"react-dom/client\"; const container = document.getElementById('root'); const root = ReactDOM.createRoot(container); //ReactDom里有一个render方法，功能就是把组件渲染并且构造DOM树，然后插入到页面上某个特定的元素上 root.render( //这里比较奇怪了，它并不是一个字符串，看起来像是纯HTML代码写在JavaScript代码里面。 //\"在JavaScript写的标签的\"语法叫JSX-JavaScript XML 欢迎使用react的世界 文件 ) 六、JSX语法与组件 1.JSX语法 JSX将html语法直接加入到JavaScript代码中，再通过翻译器转换到纯JavaScript后由游览器执行。在实际开发中，JSX在产品打包阶段都已经编译成纯JavaScript，编译过程由Babel的JSX编译器实现。 JSX原理 JSX-使用react构造组件，bable进行编译->JavaScript对象->ReactDOM.render()->DOM元素->插入页面 2.class组件 ES6的加入让JavaScript直接支持使用class来定义一个类，react创建组件的方式就是使用的类的继承，ES6 class是目前官方推荐的使用方式，它使用了ES6标准语法来构建 react中创建组件 组件-JS+HTML+CSS绑定到一个文件内，方便复用； es6 类 class Test { constructor(){ this.a = 23; } testA(){ console.log(this.a) } } class ChildTest extends Test{ testB(){ console.log(this.a) } } var obj = new ChildTest(); obj.testB(); 3.React类组件 定义组件 - return中保证最外层只有一个标签 import React from \"react\"; //只有继承React.Component才为定义一个组件，否则为定义一个类 class WeiShanApp extends React.Component{ render(){ return //js return 后面加回车 返回undefined Hello React Component 1 2 //为jsx语法 } } export default WeiShanApp; 使用组件 - import的时候需要使用首字母大写，否则会当游览器默认标签 import React from \"react\"; import ReactDOM from \"react-dom/client\"; import App from \"./01-base/01-class组件\"; //使用组件部分 const container = document.getElementById('root'); const root = ReactDOM.createRoot(container); root.render( // React.createElement(\"div\",{ // id:\"aaa\", // className:\"bbb\" // },\"123\") //使用组件部分 ); 4.函数组件 16.8之前无状态组件 16.8之后 react hooks 定义组件 function App(){ return( function Component ) } export default App; 使用与类组件相同 5.组件间嵌套 重要 - vscode安扩展可以用快捷键自动生成类组件必要代码 组件名 - VS Code ES7 React/Redux/React-Native/JS snippets 快捷键 - 输入rcc + 回车 = 生成类组件必要代码 . 组件嵌套 import React, {Component} from 'react' class Navbar extends Component{ render(){ return( Navbar ) } } function Swiper(){ return ( Swiper ) } //es6 箭头函数 箭头函数后面为该函数返回值 const Tabbar =()=>Tabbar class App extends Component{ render() { return ( ) } } export default App; 6.组件的样式 react推荐我们使用行内样式，因为React觉得每一个组件都是一个独立的整体 import React, { Component } from 'react' import './css/01-index.css' //导入css模块 webpack的支持！ export default class App extends Component { render() { let myName = \"WeiShan\" var obj = { backgroundColor:\"yellow\", //单一属性去掉 - 驼峰写法 fontSize:\"30px\" } //jsx标签中 使用 {} 内判断为js return ( {10+20}{myName} {10>20?\"aaa\":\"bbb\"} 1234 1234 1234 1234 用户名 ) } } 7.事件绑定 ①几种事件绑定的方法 import React, { Component } from 'react' export default class App extends Component { render() { return ( {/* 方法一 如果处理逻辑过多，不推荐这种 */} { console.log(\"click1\"); } }>add1 {/* 方法二 */} add2 {/* 方法三 */} add3 {/* 方法四 比较推荐 */} { this.handleClick4() } }>add4 ) } handleClick2 = ()=>{ console.log(\"click2\"); } handleClick3(){ console.log(\"click3\"); } handleClick4(){ console.log(\"click4\"); } } ②几种事件绑定中this的指针域 js中改变this指向 /** * 改变this指向的方法 * * call 改变了this指向，并自动执行函数 * apply 改变了this指向，并自动执行函数 * bind 改变了this指向，手动加 () 执行函数 */ var obj1 = { name:\"obj1\", getName(){ console.log(this.name) } } var obj2 = { name:\"obj2\", getName(){ console.log(this.name) } } obj1.getName.call(obj2) // 修改this指向 调用 call obj1.getName.apply(obj2) // 修改this指向 调用 apply obj1.getName.bind(obj2) // 修改this指向 不调用 bind obj1.getName.bind(obj2)() // 函数调用使用 () 执行函数 obj2.getName() 优化方法四说明this指针域 import React, { Component } from 'react' export default class App extends Component { a = 100 render() { return ( {/* 方法一 可以调用 this.a 箭头函数里面 this与外面render指针域一样 */} { console.log(\"click1\",this.a); } }>add1 {/* 方法二 可以调用 this.a 箭头函数里面 this与外面render指针域一样*/} add2 {/* 方法三 不可调用 this.a 被reatc事件系统调用，this指向react事件系统不是app实例*/} add3 {/* bind 可以绑定来修正 */} {/* 方法四 比较推荐 传参的时候方便 */} this.handleClick4()}>add4 ) } handleClick2 = ()=>{ console.log(\"click2\",this.a); } handleClick3(){ //这函数谁调用this指向谁 console.log(\"click3\",this.a); } handleClick4(){ console.log(\"click4\",this.a); } } ③.事件绑定注意事项与面试 --react事件绑定与普通事件绑定的区别    react并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式；占用内存小； 点击按钮有捕获与冒泡的过程，react模拟：从事件源一直找到根节点，有对应事件就执行； react把时间绑定到代理身上(根节点，移除根节点上事件绑定就失效) handleClick2 = (ref)=>{ console.log(\"click2\",this.a,ref.target); //输出为 click2 100 add2 } 复习 import React,{Component} from \"react\"; import \"./css/01-index.css\"; /** * 练习三种组件 - 出错 注意首字母大写 * - 组件写行内样式时候，样式单独定义为object，使用{}给style引入样式变量 */ class Navigator extends Component{ render(){ var styleNav = {backgroundColor:\"red\"} return navigator } } function Content(){ return content } var Bottom = () =>{ return (bottom) } var Other = () => other class App extends Component{ cha = 'this pointer' render(){ var click1 = { userSelect:\"none\" } return ( {/* 事件绑定 */} 用户名 {console.log(\"click1\",this.cha)} }>按钮1 按钮2 按钮3 {this.click4()} }>按钮4 ) } click2(){ console.log(\"click2\",this.cha) } click3 = ()=>{ console.log(\"click3\",this.cha) } click4 = () =>{ console.log(\"click4\",this.cha) } } export default App 8.ref的应用 ref 引用 myref = React.createRef() 可以绑定在标签或者组件上 ref={this.myref} 通过下面方法访问到 this.myref.current import React, { Component } from 'react' export default class App extends Component { a = 100 myref = React.createRef() render() { return ( this.handleClick()}>add ) } handleClick(){ console.log(\"click\",this.myref.current.value); //添加current属性才可以拿到dom } } 七、组件的数据挂载方式 1.状态 状态就是组件描述某种显示情况的数据，由组件自己设置和更改，也就是说由组件自己维护，使用状态的目的就是为了在不同的状态下使组件的显示不同(自己管理) 1.初识状态 定义为全局对象，名字固定位state 使用this.state调用 import React, { Component } from 'react' export default class App extends Component { //变量名字固定 state = { myText:\"收藏\", //未用 myShow:true } render() { return ( React开发 { this.setState( { myShow:!this.state.myShow } ) if(this.state.myShow){ console.log(\"执行收藏的逻辑\") }else{ console.log(\"取消收藏的逻辑\") } } }>{this.state.myShow?'收藏':\"取消收藏\"} ) } } 另外： 可以在构造函数中定义状态，但是注意继承构造函数中应有super()* //第二种定义状态的方法 constructor(){ super() this.state = { myShow:true } } ES6中的派生类，就是extend的class。派生出的构造函数不会创造新的this对象(或者说this指向的对象(这里可以回顾一下new关键字做的事情)，就是所说的\"子类没有自己的this\"。只有通过super()把基类创建好的this对象接下来，派生类才能像基类一样使用this来生成对象的属性。 JavaScript 强制要求在 constructor 中使用 this 之前，必须先调用 super（继承）。 且 可以一下修改多个状态值 this.state = { myShow:true, myText:\"未命名\", myName:\"微山\" } this.setState( { myShow:!this.state.myShow, myText:\"已命名\" } ) 2.循环渲染 JS中${}使用!! et age = prompt('How old are you',100); alert('You are ${age} years old') //You are 100 years old! JS中map()方法！！ map定义和方法 map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值。 map()方法按照原始数组元素顺序依次处理元素。 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 var array1 = [1,4,9,16]; const map1 = array1.map(x => x *2); console.log(map1); --循环渲染部分-- import React, { Component } from 'react' export default class App extends Component { state = { list:[ {id:1,text:\"1\"},{id:2,text:\"2\"},{id:3,text:\"3\"} ] } render() { var newList = this.state.list.map(item=>{item.text}) return ( {/* 第一种 */} {/* {this.state.list.map(item=>{item})} */} {/* 第二种 */} {newList} ) } } 3.key值 为了列表的复用和重排，设置key值，提高性能 理想key值是 item.id 不涉及到列表的增加删除，重排，设置成索引没有问题 key值为每个元素的唯一标识 循环渲染不适用key，虚拟dom发生变化时候，会比较新的虚拟dom与原来的比较(diff)，例如删除原来中的一个，需要对比前后虚拟dom来确定哪个发生变化而重新渲染，加上key可以快速定位到哪个被改变； 状态使用key值 state = { list:[ {id:1,text:\"1\"},{id:2,text:\"2\"},{id:3,text:\"3\"} ] } var newList = this.state.list.map(item=>{item.text}) map可以传递两个参数 var newList = this.state.list.map((item,index)=>{item.text}) 4.todolist 涉及深拷贝浅拷贝 react不建议直接修改状态-可能造成不可预期的错误 import React, { Component } from 'react' export default class App extends Component { myRef = React.createRef() constructor(){ super() this.state = { state: true, list:[ {id:1,text:\"111\"}, {id:2,text:\"222\"}, {id:3,text:\"333\"} ], } } render() { return ( { this.myRefClick(); } }>添加 {this.state.list.map(item=>{item.text})} {this.setState({state:!this.state.state})} }> {this.state.state?\"收藏\":\"取消收藏\"} ) } myRefClick = ()=>{ console.log(\"点击\",this.myRef.current.value) //不推荐 更新数组 不要直接修改状态 - 可能造成不可预期的状态 // this.state.list.push({ // id:this.myRef.current.value, // text:this.myRef.current.value // }) //js处理复杂数据类型赋值方式为引用赋值(多一把钥匙) //不推荐 ！！注意 此下为引用赋值 也属于上面那种直接修改的 // let newList = this.state.list // newList.push(this.myRef.current.value) //深复制(深拷贝) slice()方法、[...arr]方法 let newList_ = [...this.state.list] newList_.push({ id:Math.random()*100, //生成不同id的函数 text:this.myRef.current.value }) //重新渲染 this.setState( { list:newList_ } ) } } todolist删除部分 方法一：通过map方法循环渲染的时候可以通过(item,index)=>想要映射的内容中index值 通过函数参数传递的方法获取到是删除了哪个节点 {this.state.list.map((item,index)=> {item.text} { this.handleDelClick(index); } }>删除 )} handleDelClick = (index) => { console.log(\"点击删除\",index) } 方法二：bind(this,\"111\")后中\"111\"也可以进行参数传递 删除 执行删除方法 handleDelClick = (index) => { console.log(\"点击删除\",index) //不要直接修改原状态，造成不可预期问题 let newList = this.state.list.slice(); //slice newList.splice(index,1); //splice console.log(newList) this.setState( { list:newList } ) } 条件渲染部分 {/* 条件渲染部分 */} {/* 方案一 */} {this.state.list.length === 0 ?条件渲染一:null} {/* 方案二 利用 && 前面为真后面才有机会执行 */} {this.state.list.length ===0 && 条件渲染二} {/* 方案三 已经创建好 动态控制class来控制显示与隐藏 */} 条件渲染三 5.dangerouslySetInnerHTML import React, { Component } from 'react' export default class App extends Component { constructor(){ super() this.state = { myhtml:\"解析标签\" } } render() { return ( {/* 可以用到那时很危险，足够信任代码片段，后端返回接口数据 */} ) } } 6.数据请求 - axios 安装 axios npm i axios 数据请求部分代码 import React, { Component } from 'react' import axios from 'axios'; export default class Cinema extends Component { // 请求数据部分，暂时放到构造函数里面 后面的生命周期函数更适合发送ajax constructor(){ super() //axios 第三方的库，专门用于请求数据 axios封装给予es6的promise // axios.get(\"请求地址\").then(res=>{}).catch(err=>{console.log(err)}) //简写方式 // axios.get(\"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159\").then(res=>{ // console.log(res) // }).catch(err=>{ // console.log(err) // }) axios({ url:\"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159\", method:\"get\", headers:{ 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.2.1\",\"e\":\"1660142019135536282959873\",\"bc\":\"110100\"}', 'X-Host': 'mall.film-ticket.cinema.list' } }).then(res=>{ console.log(res.data.data.cinemas) }) console.log(\"qwe\") } render() { return ( Cinema ) } } ！！！严格模式下 -- StrticMode默认会执行两次render，来检测你的render函数有没有副作用。 7.setState同步异步 setState()更新状态的2种写法 1). setState(updater, [callback]), updater为返回stateChange对象的函数: (state, props) => stateChange 接收的state和props被保证为最新的 2). setState(stateChange, [callback]) stateChange为对象, callback是可选的回调函数, 在状态更新且界面更新后才执行 总结 对象方式是函数方式的简写方式 如果需要在setState()后获取最新的状态数据, 在第二个callback函数中读取 连续多次调用setState页面怎么执行 ①setState()更新状态是异步还是同步的? 1). 执行setState()的位置? 在react控制的回调函数中: 生命周期勾子 / react事件监听回调 => 异步 非react控制的异步回调函数中: 定时器回调 / 原生事件监听回调 / promise回调 /... => 同步 ②.关于异步的setState() 多次调用, 如何处理? setState({}): 合并更新一次状态, 只调用一次render()更新界面 ---状态更新和界面更新都合并了 setState(fn): 更新多次状态, 但只调用一次render()更新界面 ---状态更新没有合并, 但界面更新合并了 如何得到异步更新后的状态数据? 在setState()的callback回调函数中 为什么在react相关调用中是异步，其它是同步？ 在react中用到了【事务】，它存在就是异步，而react之外未用到【事务】所以就是同步。 react18版本之后的变化 React18新特性：Automatic batching 自动批处理 什么是批处理(batchedUpdates)：React会尝试将同一上下文中触发的更新合并为一个更新 关于批处理部分内容 批处理的好处 合并不必要的更新，减少更新流程调用次数 状态按顺序保存下来，更新时不会出现「竞争问题」 最终触发的更新是异步流程，减少浏览器掉帧可能性 批处理的几种类型 v18的「批处理」是自动的 v18之前的 React 使用半自动的「批处理」. React同时提供了一个API 手动 「批处理」unstable_batchedupdates . 关于手动批处理 onClick() {setTimeout(() => { ReactDOM.unstable_batchedUpdates(() => { this.setState({a: 3}); this.setState({a: 4}); }) }) } v18的自动批处理 实现： 增加调度的流程 不以全局变量executionContext为批处理依据，而是以更新的「优先级」为依据 什么是优先级? 调用this.setState后源码内部会依次执行： 根据当前环境选择一个「优先级」lane 创造一个代表本次更新的update对象，赋予他步骤1的优先级 将update挂载在当前组件对应fiber（虚拟DOM）上 进入调度流程 每次调用this.setState会产生update对象，根据调用的场景他会拥有不同的lane（优先级） 调度流程 在组件对应fiber挂载update后，就会进入「调度流程」。 试想，一个大型应用，在某一时刻，应用的不同组件都触发了更新。 那么在不同组件对应的fiber中会存在不同优先级的update。选出这些update中优先级最高的那个，以该优先级进入更新流程。 -整个过程: 获取当前所有优先级中最高的优先级 将步骤1的优先级作为本次调度的优先级 看是否已经存在一个调度 如果已经存在调度，且和当前要调度的优先级一致，则return 不一致的话就进入调度流程 自动批处理流程 onClick() { this.setState({a: 3}); this.setState({a: 4}); this.setState({a: 5}); this.setState({a: 6}); } 只有第一次调用会执行调度，后面几次执行由于优先级和第一次一致会return。 当一定时间过后，第一次调度的回调函数performConcurrentWorkOnRoot会执行，进入更新流程。 由于每次执行this.setState都会创建update并挂载在fiber上。 所以即使只执行一次更新流程，还是能将状态更新到最新。 调度的最终目的是在一定时间后执行performConcurrentWorkOnRoot，正式进入更新流程。 8.BetterScroll BetterScroll是一款重点解决移动端(已支持PC)各种滚动场景需求的插件，使用纯JavaScript实现的，这意味着它是无依赖的。 使用条件 父盒子高度一定 子盒子被撑开 overflow：hidden 需要注意再react中使用需要dom渲染完成之后再new import React, { Component } from 'react' import BetterScroll from 'better-scroll' export default class App extends Component { state = { list:[] } render() { return ( {this.getData()} }>click {this.state.list.map(item=>{item})} ) } //点击按钮赋值 getData(){ var list = [1,2,3,4,5,6,7,8,9,10,11,12,13,14]; this.setState({ list:list },()=>{ //放在setState回调函数中，等dom渲染完成之后再调用 new BetterScroll(\".wrapper\") }) } } 2.属性(props) 1.初识属性 父组件调用时候传入属性，子组件根据传入属性复用： 父组件： render() { return ( 首页 {/* 调用navabar的时候加了一个属性 title */} 列表 购物车 ) } 子组件： state = { //只能内部自己用的，外面无法改变 } //属性是父组件传来的,this.props render() { // console.log(this.props.title) let {title,leftShow} = this.props // console.log(leftShow) return ( {leftShow && 返回} Navbar-{title} home ) } 对象属性与类属性 //类属性 不用new 就能访问到 Navbar.propTypes = { title:propTypes.string, leftShow:propTypes.bool } class Test{ //此处a为对象属性 a = 1 } //类属性，不用new就能访问 Test.a = 100 var obj = new Test(); console.log(obj.a) // 1 console.log(Test.a) // 100 es7中的类属性 class Test{ //此处a为对象属性 a = 1 //类属性 static a =101 } 应用到属性验证 //类属性 不用new 就能访问到 Navbar.protoTypes = { title:验证是不是字符串的方法, leftShow:验证是不是bool的方法 } 2.属性验证 引入react中属性验证模块 //react中属性验证模块 - prop-types import propTypes from 'prop-types' 组件中做好属性验证 - propTypes关键字 放在类外面 //类属性 不用new 就能访问到 Navbar.propTypes = { title:propTypes.string, leftShow:propTypes.bool } 属性验证的推荐写法-使用static关键字 static propTypes = { title:propTypes.string, leftShow:propTypes.bool } 3.默认属性 关键字 defaultProps static defaultProps = { leftShow:true } 4.属性注意 展开写法 //上面父组件传来的 var obj = { title:\"测试\", leftShow:false } {/* 当与传入子组件参数一致时候，可以使用es6展开语法 */} 函数式组件使用属性 函数式组件使用形参接受属性 function Sidebar(props){ //函数式组件接受属性 let {bg,position} = props let obj1 = { left:0 } let obj2 = { right:0 } let obj = { background:bg, width:\"200px\", position:\"fixed\" } let styleObj = position===\"left\"?{...obj,...obj1}:{...obj,...obj2} return( 2 2 2 2 2 2 2 ) } //属性验证 Sidebar.defaultProps( {} ) Sidebar.prototype( { } ) export default Sidebar; isRequire使用 使用isRequire当组件调用的时候不传指定属性会报错 //类属性 不用new 就能访问到 static propTypes = { title:propTypes.string, leftShow:propTypes.bool.isRequired } 但是！ 如果指定参数设置 defaultProps的话，不会报错 static propTypes = { title:propTypes.string, leftShow:propTypes.bool.isRequired } static defaultProps = { leftShow:true } 与 创建dom可用的语法不同前者使用document.createElement('H2',content)的方式 后者使用 const vDom2 = {msg} 来创建dom 3.属性VS状态 属性不能在组件内修改(但是可以给默认值)，状态要在组件内部修改； 没有state的组件叫做无状态组件(stateless component),设置了state的叫做有状态组件(stateful component)。因为状态会带来管理的复杂性，我们尽量写无状态的组件。这样会降低代码的维护难度，也会一定成都上增加组件的可复用性。 ！！！父组件调用子组件的时候 重新更新调用传新属性的时候，子组件只会执行render函数，不会实例化两遍类(construct) 父组件状态传给孩子属性-标准 import React, { Component } from 'react' import lxq from 'prop-types' class Child extends Component{ constructor(){ super() console.log(\"子组件控制器\") } static propTypes = { text:lxq.string } render(){ console.log(\"子组件渲染\") return(Child-{this.props.text}); } } export default class App extends Component { state = { text:\"123\" } render() { return ( { this.setState( { text:\"222\" } ,()=>{ console.log(this.state.text) }) } }>父组件按钮 {this.state.text} ) } } 4.渲染数据 ...... 八.表单中的受控组件与非受控组件 1.非受控组件 import React, { Component } from 'react' import { createRef } from 'react' export default class App extends Component { idRef = createRef() render() { return ( 登录页面 {this.login()} }>登录 {this.clearInput()} }>重置 ) } //登录操作 login = ()=>{ var userName = this.idRef.current.value //检查及提交数据 console.log(userName) } //清除输入框内容 clearInput = ()=>{ this.idRef.current.value = \"\" } } 2.受控组件 例子：输入框跟状态绑定 受控组件注意重置与登录操作直接调用state import React, { Component } from 'react' export default class App extends Component { state = { userName:\"WeiShan\" } render() { return ( 登录页面 {this.login()} }>登录 {this.clearInput()} }>重置 ) } //监听输入框值 changeInput = (evt)=>{ console.log(\"onChange\",evt.target.value) this.setState( { userName:evt.target.value } ) } //登录操作!!! login = ()=>{ console.log(this.state.userName) } //清除输入框内容!!! clearInput = ()=>{ this.setState( { userName:'' } ) } } 受控组件的应用：当指定值改变会影响其余小组件或样式改变的时候使用受控组件 例子：todolist受控组件，input->checkbox影响指定样式 import React, { Component } from 'react' import \"./css/01-index.css\" export default class App extends Component { myRef = React.createRef() constructor(){ super() this.state = { state: true, list:[ {id:1,text:\"111\",isChecked:false}, {id:2,text:\"222\",isChecked:false}, {id:3,text:\"333\",isChecked:true} ], inputText:'' } } render() { return ( { this.addClick(); } }>添加 {this.state.list.map((item,index)=> {this.handleSelect(index)} }/> {item.text} { this.handleDelClick(index); } }>删除 )} {/* 条件渲染部分 */} {/* 方案一 */} {this.state.list.length === 0 ?条件渲染一:null} {/* 方案二 利用 && 前面为真后面才有机会执行 */} {this.state.list.length ===0 && 条件渲染二} {/* 方案三 已经创建好 动态控制class来控制显示与隐藏 */} 条件渲染三 {this.setState({state:!this.state.state})} }> {this.state.state?\"收藏\":\"取消收藏\"} ) } //输入框内容改变 inputChange = (evt) => { this.setState( { inputText:evt.target.value } ) } //点击添加按钮 addClick = () => { var newList = [...this.state.list] newList.push({id:parseInt(Math.random()*1000),text:this.state.inputText,isChecked:false}) this.setState( { list:newList, inputText:'' } ) } //点击删除按钮 handleDelClick = (index) => { var delList = this.state.list.slice() delList.splice(index,1) this.setState( { list: delList } ) } //点击选择按钮 handleSelect = (index) => { let newList = this.state.list.slice() newList[index].isChecked = !this.state.list[index].isChecked this.setState( { list:newList } ) } } 总结 对于受控组件来说，输入的值始终有react的state驱动，可以将value传递给其他ui元素，或者通过其他事件处理函数重置，但这意味着需要编写更多的代码； 注意：另外一种说法(广义范围的说法)，React组件的数据渲染是否被调用者传递的props完全控制，控制则为受控组件，否则为非受控组件。 九.组件的通信方式 1.父组件通信方式 1.传递数据-字符串等(父传子)与传递方法-回调函数(子传父) 例子：父组件调用子组件时候传入回调函数属性，子组件在哪调用在哪执行 //父组件传入属性(回调函数) { this.setState( { isShow:!this.state.isShow } ) } }> //子组件在需要地方调用父组件传入 回调函数 属性 { // 通知父组件让isSHow取反 this.props.event() //调用父组件的回调函数 } }>click navbar 插入： 非受控组件，孩子有状态导致没办法根据父组件内状态改变多个子组件的状态 例子： 卖座选项卡内底部导航栏的组件使用自己的状态来切换选中值，并且通过父传子的回调函数实现底部导航栏切换的时候，使用子父的方法来实现主页面内页面切换(父组件内内容切换)；但是多建了个顶部导航栏组件中有个按钮定位到center时候，就没办法将主页面选中的选项同步给 顶部导航栏组件，所以使用了非受控组件导致，没办法统一页面上选中的内容； 利用父组件与子组件通信，状态定义在父组件内的方法，实现受控组件的定义； 2.ref标记(父组件拿到子组件的引用，从而调用子组件的方法) 在父组件中清楚子组件的input输入框的value值。this.refs.from.reset() (1)定义ref，并在调用自组件的时候传入 username = React.createRef() password = React.createRef() (2)可以直接调用子组件value以及子组件定义的函数 { console.log(this.username.current.state.value, this.password.current.state.value) } }>登录 { this.username.current.clear() this.password.current.clear() } }>重置 2.非父子组件通信方式 (1)状态提升(中间人模式) React中的状态提升概括来说，就是将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件； 比较适合亲兄弟组件相互之间传递 例子部分代码： 子组件通过父组件回调方法传递给父组件该改变值，父组件传递属性到其他子组件 import React, { Component } from 'react' import axios from 'axios' import './css/03-communication.css' export default class App extends Component { constructor(){ super() this.state = { filmList:[], info:'' } axios.get('/test.json').then( res=>{ this.setState( { filmList:res.data.data.films } ) } ) } render() { return ( //父传子(回调函数，用于接收子组件传递参数) {this.state.filmList.map( item=>{ this.setState({ info:value }) } } key={item.filmId} {...item}> )} //子组件通过回调函数传参数给父组件之后，父组件通过属性传递给子组件 ) } } class FilmItem extends Component{ render(){ // console.log(this.props) let {name,poster,grade,synopsis} = this.props return( { this.props.onEvent(synopsis) } }> {this.props.name} 观众评分：{grade} ) } } class FilmDetail extends Component{ render(){ return( {this.props.detail} ) } } (2)发布订阅模式实现 js实现简单的发布订阅模式 这里的callback && callback(data);相当于 if callback {callback()}; 如果回调函数存在，则执行该回调函数。 var bus = { list:[], //订阅 subscribe(callback){ this.list.push(callback) }, //发布 publish(){ //遍历所有list，将回调函数执行 this.list.forEach(callback=>{ callback&&callback(); }) } } //订阅 bus.subscribe(()=>{ console.log(\"订阅1\") }); bus.subscribe(()=>{ console.log(\"订阅2\") }); //发布 bus.publish(); react利用发布订阅模式实通信 import React, { Component } from 'react' import axios from 'axios' import './css/03-communication.css' var bus = { list:[], //订阅 subscribe(callback){ this.list.push(callback) }, //发布 publish(content){ //遍历所有list，将回调函数执行 this.list.forEach(callback=>{ callback&&callback(content); }) } } export default class App extends Component { constructor(){ super() this.state = { filmList:[], } axios.get('/test.json').then( res=>{ this.setState( { filmList:res.data.data.films } ) } ) } render() { return ( {this.state.filmList.map( item=> )} ) } } class FilmItem extends Component{ render(){ // console.log(this.props) let {name,poster,grade,synopsis} = this.props return( { // console.log(synopsis) bus.publish(synopsis) } }> {this.props.name} 观众评分：{grade} ) } } class FilmDetail extends Component{ constructor(){ super() bus.subscribe((content)=>{ this.setState( { content:content } ) }) this.state = { content:'' } } render(){ return( {this.state.content} ) } } (3)context状态树传参 定义全局context const GlobalContext = React.createContext() //创建context对象 生产者提供属性与回调方法 // 生产者 { this.setState({ info:value }) } } }> {this.state.filmList.map( item=> )} 消费者调用参数及回调方法 { (value)=> {value.info} } 关于插槽 1.为了复用（多种类型dom）-例：轮播(图片或视频) 2.减少父子通信 父组件调用子组件 1111 2222 3333 子组件定义插槽 child {/* 插槽 vue slot */} {this.props.children[0]} {this.props.children[1]} {this.props.children[2]} 十.React生命周期 1.初始化阶段 生命周期函数 - 钩子函数 componentWillMount: render之前最后一次修改状态的机会 1.将要挂载,拿不到dom - 在这里可以进行状态初始化 render：只能访问this.props和this.state，不允许修改状态和DOM输出 componentDidMount:成功render并渲染完成真是DOM之后触发，可以修改DOM 1.数据请求axios/ajax 2.订阅发布模式中的订阅函数的调用 例： import React, { Component } from 'react' export default class App extends Component { state = { myName:\"WeiShan\" } //将要挂载,拿不到dom - 在这里可以进行状态初始化 componentWillMount(){ console.log(\"will mount\",this.state.myName) //第一次上树前的最后一次状态修改机会 this.setState( { myName:\"WeiShanVerify\" } ) //初始化数据的作用。 } //已经渲染完，可以拿到真实的dom节点 componentDidMount(){ console.log(\"did mount\") //数据请求axios/ajax //订阅发布模式中的订阅函数的调用 } render() { console.log(\"render\") return ( {this.state.myName} ) } } 关于willmount生命周期函数弃用： react16.2版本之后react算法更改之后， 1.可以在前面加UNSAFE_ 变成 UNSAFE_componentWillMount 关于为什么不安全： fiber技术：优化虚拟dom递树算法，高优先级任务打断低优先级任务，willmount忙着找到哪些状态需要更新，能被打断，更新dom状态的过程是不能被打断的，被高优先级任务打断之后会再执行一次 2.运行中阶段 componentWillReceiveProps：父组件修改属性触发 shouldComponentUpdate：返回false会阻止render调用 componentWillUpdate：不能修改属性和状态 render：只能访问this.props和this.state,不允许修改状态和DOM输出 componentDidUpdate(prevProps,prevState)：可以修改DOM,两个形参为老属性与老状态 例子：主DidUpdate 在本地读取数据的时候，第一次初始化完成就可以使用didmount来进行操作dom，使用异步调用之后重新渲染数据，使用DidUpdate来操作dom 缺点didupdate 会执行多次，每次setstate之后都回调用didupdate import axios from 'axios' import React, { Component } from 'react' import BetterScroll from 'better-scroll' export default class App extends Component { state = { myName:\"WeiShan\", list:[] } componentDidMount(){ axios.get(\"/test.json\").then(res=>{ this.setState({ list:res.data.data.films }) console.log(\"调用\",document.getElementById('warpper')) //这个不好用 本地读取数据 不是第一次初始化的时候用下面didUpdate // new BetterScroll('#warpper') }) } render() { return ( { this.setState( { myName:\"TeiChui\" } ) } }>点击 {this.state.myName} {this.state.list.map(item=>{item.name})} ) } UNSAFE_componentWillUpdate(){ console.log(\"componentWillUpdate\",document.getElementById('my_name').innerHTML) } componentDidUpdate(prevProps,prevState){ console.log(\"commponentDidUpdate\",document.getElementById('my_name').innerHTML) console.log(prevState.list) //更新后，想要获取dom节点 ， 更新 if(prevState.list.length === 0){ new BetterScroll('#warpper') console.log(\"执行操作\") } } } shouldComponentUpdate -- 性能优化函数 判断什么时候需要更新状态 -- scu //输入scu回车 可以生成以下函数 shouldComponentUpdate(nextProps,nextState){ // return false; //阻止更新 //return true; //应该更新 if(JSON.stringify(this.state) !== JSON.stringify(nextState)){ return true; } return false; } shouldComponentUpdate案例： 举例了父组件改变某个值影响子组件重新渲染，当子组件内容过多的时候，考虑性能优化，不优化每次一state更新都导致孩子render执行，在scu中进行属性与nextProps对比,如果上一次两个属性 或者 下一次两个属性相等的情况下，说明有属性变动，则修改； this.state 老的状态 - 不要直接修改状态(this.state.list = newState) nextState 新的状态 componentWillReceiveProps 最先获得父组件传来的属性，可以利用属性进行ajax或者逻辑处理 把属性转化成孩子自己的状态 使用： // 用于子组件 UNSAFE_componentWillReceiveProps(nextProps){ console.log(\"willReceiveProps\") //获取到的属性为老属性、 console.log(this.props.text) //新的属性 console.log(nextProps.text) //最先获得父组件传来的属性，可以利用属性进行ajax或者逻辑处理 //把属性转化成孩子自己的状态 this.setState( { title:nextProps.text+\"WeiShan\" } ) } 案例： 子组件根据传来属性请求响应数据(初始化用willmount，后续改变用willreceiveprops) class FilmList extends Component{ //第一次 只会在初始化阶段执行的函数 UNSAFE_componentWillMount(){ if(this.props.type === 1){ console.log(\"请求正在热映的数据\") }else{ console.log(\"请求即将上映的数据\") } } render(){ return( FilmList ) } //后续变化 UNSAFE_componentWillReceiveProps(nextProps){ if(nextProps.type ===1){ console.log(\"请求正在热映的数据\") }else{ console.log(\"请求即将上映的数据\") } } } 3.销毁阶段 componentWillUnmount：在删除组件之前进行清理操作，比如计时器和事件监听器 //被销毁时候调用这个生命周期 //组件被销毁，组件内部的监听会销毁，但是绑定在window窗口的事件监听不会销毁 - 定时器等 componentWillUnmount(){ console.log(\"componentWillUnmount\") window.onresize = null clearInterval(this.timer) } 老生命周期的问题 (1)componentWillMount,在ssr中这个方法将会被多次调用，所以会重复触发多遍，同时在这里如果绑定事件，将无法解绑，导致内存泄露，变得不够安全高效逐步废弃。 (2)componentWillReceiveProps外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求 (3)componentWillUpdate, 更新前记录DOM状态，可能会做一些处理，与componentDidUpdate相隔时间如果过长，会导致 状态不太信 新生命周期的替代 (1) getDerivedStateFromProps 第一次的初始化组件以及后续的更新过程中(包括自身状态更新以及父转子)，返回一个对象作为新的state，返回null则说明不需要在这里更新state 使用 //这个是类方法 componentWillMount static getDerivedStateFromProps(nextProps,nextState){ console.log(\"123\",nextState) //return对象会跟state合并 return { myName:nextState.myName.substring(0,1).toUpperCase()+nextState.myName.substring(1), }; } 案例 使用getDerivedStateFromProps 代替 UNSAFE_componentWillReceiveProps实现后续属性变化之后重新修改页面信息 功能模块-用户点击父组件中的按钮，子组件处理父组件传来的属性，异步请求不同接口的数据 componentDidMount(){ if(this.props.type === 1){ console.log(\"请求正在热映的数据\") }else{ console.log(\"请求即将上映的数据\") } } //这里只更新状态 static getDerivedStateFromProps(nextProps){ console.log(\"执行了 getDerivedStateFromProps\") //进行异步请求之后 return { type:nextProps.type } } componentDidUpdate(prevProps,prevState){ if(this.state.type === prevState.type){ return } console.log(prevState.type,this.state.type) if(this.state.type === 1){ console.log(\"请求正在热映的数据\") }else{ console.log(\"请求即将上映的数据\") } } (2) getSnapShotBeforeUpdate 取代了componentWillUpdate, 触发时间为update发生的时候，再render之后dom渲染之前返回一个值，作为componentDidUpdate的第三个参数。 更新执行顺序 - render->getSnapshotBeforeUpdate(返回一个值到didupdate第三个参数)->componentDidUpdate 案例 记录滚动距离实现无感知来消息 //获取容器高度 getSnapshotBeforeUpdate(){ console.log(this.myRef.current.scrollHeight) return this.myRef.current.scrollHeight } componentDidUpdate(prevProps,prevState,value){ console.log(this.myRef.current.scrollHeight) this.myRef.current.scrollTop += this.myRef.current.scrollHeight-value } react中性能优化的方案 1.shouldComponentUpdate 控制组件自身或者子组件是否需要更新，尤其在子组件非常多的情况下，需要进行优化 2.PureComponent PureComponent会帮你比较新props跟旧的props，新的state和老的state(值相等，或者对象含有相同的属性、且属性相等)，决定shouComponentUpdate返回true或者false，从而决定要不要render function。 注意： 如果state或props【永远都会变】，那PureComponent并不会比较块，因为shallowEqual也需要花时间。 例子： - import PureComponent 并继承 import React, { PureComponent } from 'react' export default class App extends PureComponent { state = { myName:\"WeiShan\" } render() { console.log(\"render\") return ( { this.setState( { myName:\"xiaoming\" } ) } }>点击 {this.state.myName} ) } componentDidUpdate(){ console.log('componentDidUpdate') } } 轮播 - swiper-造轮子与使用 同步及异步使用 异步： import React, { Component } from 'react' import Swiper,{Navigation,Pagination} from 'swiper' import 'swiper/css/bundle'; import 'swiper/css'; import 'swiper/css/navigation'; import 'swiper/css/pagination'; Swiper.use([Navigation,Pagination]) export default class App extends Component { state = { list:[] } componentDidMount() { setTimeout( ()=>{ this.setState( { list:['aaa','bbb','ccc'] } ) },1000 ) } //方案一、这里可以获取数据，并且更新dom完成渲染之后 componentDidUpdate(){ new Swiper('.swiper',{ pagination:{ el:'.swiper-pagination' } }) } render() { return ( {this.state.list.map((item,index)=> {item} )} ) } } 封装一个自己得轮播组件： 将组件轮播部分中轮播内容做成插槽，将插槽部分中含有class再做成SwiperItem组件中的插槽，引入Swipper组件可实现多内容轮播，将swipper组件中new 可选的参数做成属性(例如loop)，在使用自己定义的组件的时候传入对应的属性即可实现组件的复用多样性。 十一.React Hooks 1.使用hooks理由 高阶组件为了复用，导致代码层级复杂 生命周期的复杂 携程functional组件，无状态组件，因为需要状态，又改成class，成本高 useState(保存组件状态) -- 可以使用多个 const [state,setstate] = usestate(initialstate) 例子： RFC + tab 快速生成函数式组件 以todolist为例子，使用函数式组件加上钩子函数 useState 完成 注意是，不用ref，使用状态绑定输入框 var [text,setText] = useState('') var handleChange = (evt)=>{ setText(evt.target.value) } useEffect(处理副作用)和useLayoutEffect(同步执行副作用) *Function Component 不存在生命周期，所以不要把类组件的生命周期来与之对号入座 useEffect(()=>{ //effect return ()=>{ //cleanup } },[依赖状态；空数组表示不依赖]) 使用了某个变量，却没有申明在依赖中，当依赖的变量改变时，useEffect也不会再次执行，eslint会报警告。 例子：子组件依赖于属性的值改变 function FilmList(props) { const [list,setList] = useState([]) useEffect(()=>{ if(props.type === 1){ console.log(\"请求正在热映的数据\") setList([\"正在热映数据\"]) }else{ console.log(\"请求即将上映的数据\") setList([\"即将上映数据\"]) } },[props.type]) return ( 05-useEffect2案例-{list} ) } 类似于生命周期销毁后执行内容 例：在最后return个匿名函数，仅限于依赖为空的时候 function Child(){ useEffect(()=>{ window.onresize = () =>{ console.log('resize') } return()=>{ console.log(\"组件销毁\") //没有依赖的时候 window.onresize = null; } },[]) useEffect(()=>{ var timer = setInterval(()=>{ console.log(\"111\") },2000) return()=>{ console.log(\"组件销毁\") //没有依赖的时候 clearInterval(timer) } },[]) return( Child ) } useLayoutEffect 在实际使用时，如果想避免 页面抖动 (在useEffect里面修改DOM很有可能出现)的话，可以把需要操作DOM的代码放在useLayoutEffect里。 userEffect和useLayoutEffect有什么区别？ 简单来说就是调用的时机不同，userLayoutEffect和原来componentDidMount&componentDidUpdate一致，在react完成DOM更新后马上同步调用的代码，会阻塞页面渲染。而useEffect是会在整个页面渲染完才会调用的代码。 useCallback(记忆函数) 防止因为组件重新渲染，导致方法被重新创建，起到缓存作用，只有第二个参数变化了，才重新声明一次。 var changeName = useCallback( (newName)=>{ console.log(newName) },[name] ) {changeName(\"xiaoming\")} }>点击 //只有name改变之后，这个函数才会重新声明一次 //如果传入空数组，那么就是第一次创建后就被缓存，如果name后期改变了，拿到的还是老的name //如果不传第二个参数，每次都会重新生命一次，拿到的是最新的name 关于 useState缓存了状态以及useCallback缓存函数，实现原理-闭包(可以将变量永驻内存) ，但也会导致内存泄露 useMemo记忆组件 useCallback的功能完全可以由useMemo所取代，如果你想通过useMemo返回一个记忆函数也是完全可以的。 useCallback(fn,inputs) is equivalent to useMemo(()=>fn,inputs) 唯一区别是:useCallback不会执行第一个参数函数，而是将它返回给你，而useMemo会执行第一个函数并将函数执行结果返回给你。所以前面例子可以返回handleClick来达到储存函数的目的。 所以useCallback常用记忆事件函数，生成记忆后的事件函数并传递给子组件使用。而useMemo更适合经过函数计算得到一个确定的值，比如记忆组件。 useMemo使用案例-模糊查询 const getCinemaList = useMemo( ()=> cinemaList.filter(item=>item.name.toUpperCase().includes(inputText.toUpperCase())||item.address.toUpperCase().includes(inputText.toUpperCase()) ),[inputText,cinemaList]) useRef(保存引用值) const mySwiper = useRef(null); 如何保存变量-在react hooks 体系中？ 1.useState 2.useRef //2的例子 var myCount = useRef(0) let handleClick = ()=>{ setCount(count+1) myCount.current++ } useReducer和useContext(减少组件层级) 使用useContext之前： return( // 消费者 { //在形参中获取公共服务 (value)=>{ // console.log(value) return( { // this.props.onEvent(synopsis) value.changeInfo(synopsis) } }> {props.name} 观众评分：{grade} ) } } ) 使用useContext之后： -useContext使用案例 const value = useContext(GlobalContext) return( { // this.props.onEvent(synopsis) value.changeInfo(synopsis) } }> {props.name} 观众评分：{grade} ) useReducer - 先有Redux，hooks将其中一些理念引入到当中来 解决问题：多个组件复杂的父子通信 例子父子组件之间相互通信 import React from 'react' import axios from 'axios' import './css/03-communication.css' import { useEffect } from 'react' import { useContext } from 'react' import { useReducer } from 'react' const GlobalContext = React.createContext() //创建context对象 const reducer = (prevState,action)=>{ let newState = {...prevState} switch(action.type){ case \"setDetail\": newState.detail = action.detail return newState case \"setList\": newState.filmList = [...action.list] return newState default: return prevState; } } const initailSatate = { detail:\"\", filmList:[] } export default function App(){ const [detail,setReducer] = useReducer(reducer,initailSatate) useEffect(()=>{ axios.get('/test.json').then( res=>{ setReducer({ type:\"setList\", list:res.data.data.films }) } ) },[]) return ( // 生产者 {detail.filmList.map( item=> )} ) } function FilmItem(props){ let {name,poster,grade,synopsis} = props const {setReducer} = useContext(GlobalContext) return( { // this.props.onEvent(synopsis) setReducer({ type:\"setDetail\", detail:synopsis }) } }> {props.name} 观众评分：{grade} ) } function FilmDetail(){ const {detail} = useContext(GlobalContext) return( {detail.detail} ) } 自定义hooks 当我们想在两个函数之间共享逻辑时，我们会把它提取到第三个函数中。 必须以\"use\"开头吗？必须如此，这个约定非常重要。不遵循的话，由于无法判断某个函数是否包含对其内部Hook的调用，React将无法自动检查你的Hook是否违反了Hook的规则 将逻辑抽出来单独作为函数-让结构清晰 例子： function useCinemaList(){ const [cinemaList,setCinemaList] = useState([]) useEffect(()=>{ axios({ url:\"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159\", method:\"get\", headers:{ 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.2.1\",\"e\":\"1660142019135536282959873\",\"bc\":\"110100\"}', 'X-Host': 'mall.film-ticket.cinema.list' } }).then(res=>{ console.log(res.data.data.cinemas) setCinemaList(res.data.data.cinemas) //打印log console.log(this.state.cinemaList) // console.log(this.state.bakCinemaList) }).catch(err=>{ console.log(err); }) },[]) return {cinemaList} } //解构 使用 const {cinemaList} = useCinemaList() 十二.React路由 1.什么是路由？ 路由是根据不同url地址展示不容的内容或页面 一个针对React而设计的路由解决方案，可以友好的帮你解决React components到URL之间的同步映射关系 2.路由安装 npm install react-router-dom@5 component文件夹下放一些公共的组件，views文件夹下放一个页面下的多个视图组件 3.路由使用 (1)路由方法导入 (2)定义路由以及重定向 {/* 模糊匹配 */} {/* */} {/* 精确匹配 exact*/} 注意： 使用exact精准匹配，外面还要嵌套Switch来用 (3)嵌套路由 嵌套路由父组件路由不要精确匹配！ 父组件中使用以下完成嵌套路由 (4)路由跳转方式 声明式导航与编程式导航 声明式：影院 编程式：location.href = \"#/cinemas\" a.声明式导航 电影 影院 我的 b.编程式导航 es6字符串拼接模板 其中不是单引号 是“ ` ” const handleChangePage = (id)=>{ // console.log(\"click\") //原生js方法 // window.location.href = \"#/detail/\"+id //当前组件包含在Route中，为Route子组件，可以接受props props.history.push(`/detail/${id}`) } 动态路由 1.配置跳转及动态路由 // 1.动态路由传参 // props.history.push(`/detail/${id}`) // 2.配置 - 动态路由 2.使用其中参数 export default function Detail(props) { console.log(props.match.params.myid,\"利用id取后端拿数据\") return ( Detail ) } （5）路由传参 query传参与state传参页面刷新之后会丢失传的参数，不适合分享 // 2. query传参 // props.history.push({pathname:'/detail',query:{id:id} }) // 3. state传参 props.history.push({pathname:'/detail',state:{id:id} }) 2.路由配置-普通路由 3.使用参数 // console.log(props.location.query.id,\"利用id取后端拿数据\") console.log(props.location.state.id,\"利用id取后端拿数据\") （6）路由拦截 {/* 路由拦截 */} { return isAuth()?: } }> *注意后面使用重定向跳转，会让url与页面一致 （7）路由模式 1.游览器路由BrowserRouter 使用：没有#得路径，好看，但是真正朝后端请求要页面，后端没有对应的路径处理路径会404，不好看。 //引入 import {BrowserRouter,Route,Redirect,Switch} from 'react-router-dom' //使用 //路由地址 http://localhost:3000/films/nowplaying 2.HashRouter - 不会朝后端发请求 import {HashRouter as Router,Route,Redirect,Switch} from 'react-router-dom' //使用 //路由地址 http://localhost:3000/#/center （8）withRouter应用及原理 *关于路由组件使用render方法时候，获取props属性！ 1.可以通过父组件中属性传递给子组件 { return isAuth()?: } }> 2.withRouter - 跨级传输history等值 - 原理=高阶组件 //1.引入 import { withRouter } from 'react-router-dom' //2.包装 const WithFilmItem = withRouter(FilmItem) //*模块化写法* export default withRouter(Center) //3.使用 {list.map(item=>)} //对应组件中使用history等属性 props.history.push({pathname:'/detail',state:{id:filmId} }) 4.项目注意 (1)反向代理 1.解决跨域的几个方法 - 跨域存在于游览器端 后端允许跨域请求-access-control-allow-origin: * jsonP接口 配置反向代理 - 服务器与服务器之间没有跨域限制 cra内置好了反向代理 - create react app 1.安装核心跨域插件 http-proxy-middleware 2.在项目的src文件夹下新建setupProxy.js文件 3.配置反向代理代码 - 可配置多个 const {createProxyMiddleware} = require('http-proxy-middleware') module.exports = function(app){ app.use( '/ajax', //请求的路径 以api开头的路径需要配置反向代理 createProxyMiddleware({ target: 'https://i.maoyan.com', //上面的请求路径会转发到地址 changeOrigin: true }) ) app.use( '/gateway', //请求的路径 以api开头的路径需要配置反向代理 createProxyMiddleware({ target: 'https://m.maizuo.com', //上面的请求路径会转发到地址 changeOrigin: true }) ) } 4.修改请求部分代码-去掉域名等信息 useEffect(()=>{ axios.get(\"/ajax/mostExpected?limit=10&offset=0&token=&optimus_uuid=556A94F02F7911EDADFC891B0223160177BBBE0A5A2C422FB4DA4F00BB4ACC67&optimus_risk_level=71&optimus_code=10\").then( res=>{ console.log(res.data) } ) },[]) 5.重启服务器！！！ (2)css module 单页面应用css共享，使用import引入之后直接插入到index.html中 新建的css文件更换名为Film.module.css,会将内class名加上随机值 引入 import style from './css/Film.module.css' 更换原先类名地方 className = {style.active} 若标签选择器 则 不会重命名 ， 尽量使用class选择器 ， 使用标签选择器，可以使用父级关系做 例如 .film ul li 初始化或者多个类名的时候，可以使用字符串拼接 例如 className = {style.film} + \" aaa\" 若使用全局选择器 ：global(.active){ } 则对应类名不做变换 十三、Flux与Redux Flux是一种架构思想，专门解决软件的结构问题。它跟MVC架构是同一类东西，但是更加简单和清晰。Flux存在多种实现(至少15种) FaceBook Flux是用来构建客户端Web应用架构，它利用单向数据流的方式来组合React中的视图组件。它更像是一个模式而不是一个正式的框架，开发者不需要太多的新代码就可以快速上手Flux； Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树(state对象)保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建(使用actions和reducers)，这样就可以进行数据追踪，实现时光旅行。 1.redux介绍及设计和使用的三大原则 state 以单一对象存储在store对象中 state 只读(每次都返回一个新的对象) 使用纯函数reducer执行state更新 2.redux工作流 3.与react绑定后使用redux实现案例 项目目录下新建 redux文件夹，新建actionCreator文件夹与store.js store.js： // 1.引入redux import { createStore } from 'redux' // 2.createStore(reducer) const reducer = (prevState={ show:true },action)=>{ let newState = {...prevState} switch(action.type){ case \"hide-tabbar\": newState.show = false return newState case \"show-tabbar\": newState.show = true return newState default: return prevState } } const store = createStore(reducer); // 3.导出 export default store actionCreator文件新建文件TabbarActionCreator.js-存放需要传递的action function show(){ return { type:\"show-tabbar\" } } function hide(){ return{ type:'hide-tabbar' } } export {show,hide} 使用(发布订阅) 发布 useEffect(()=>{ // console.log(\"创建\") //store.dispatch 通知 store.dispatch(hide()) return(()=>{ store.dispatch(show()) }) },[]) 订阅 componentDidMount(){ store.subscribe(()=>{ // console.log(\"app 中订阅\",store.getState()) this.setState({ showTabbar:store.getState().show }) }) } 4.redux原理解析 新建函数替代redux的createStore() function createWeiShanStore(reducer){ var list = [] var state = reducer(undefined,{}) function subscribe(callback){ list.push(callback) } function dispatch(action){ state = reducer(state,action) for(var i in list){ list[i]&&list[i]() } } function getState(){ return state } return{ subscribe, dispatch, getState } } 纯函数 reducer是纯函数，传入老状态不改变，返回新状态 对外界变量等不产生影响（例如传入一个对象，直接操作对象会影响原对象） 同样的输入得到同样的输出（一一对应） 5.reducer扩展 redux管理的数据放在(游览器的内存中，刷新一下游览器就丢失了) 如果不同的action所处理的属性之间没有联系，我们可以把Reducer函数拆分。不同的函数负责处理不同属性，最终他们合并成一个大的Reducer即可。 redux 文件夹下新建reducers文件夹，拆分原有合并的reducer 在store.js中合并reducer //导入并合并 import CityReducer from \"./reducers/CityReducer\"; import TabbarReducer from \"./reducers/TabbarReducer\"; const reducer = combineReducers({ CityReducer, TabbarReducer }) 6.redux中间件 在redux里，action仅仅是携带了数据的普通js对象。action creator返回的值是这个action类型的对象。然后通过store.dispatch()进行分发。同步的情况下很完美，但是reducer无法处理异步的情况。 那么我们就需要在action和reducer中间架起一座桥梁来处理异步。这个就是middleware。 常用异步中间件 a. redux-thunk（store.dispatch参数可以是一个function） 1.安装redux-thunk npm i redux-thunk 2.store.js中使用 import reduxThunk from 'redux-thunk' const store = createStore(reducer,applyMiddleware(reduxThunk)); 3.构造action时候使用-actionCreator return一个函数，并且传入一个参数，在指定地方调用传入参数函数，即可异步返回指定值 import axios from \"axios\" function getCinemaListAction(){ return (dispatch)=>{ axios({ url:\"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159\", method:\"get\", headers:{ 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.2.1\",\"e\":\"1660142019135536282959873\",\"bc\":\"110100\"}', 'X-Host': 'mall.film-ticket.cinema.list' } }).then(res=>{ // console.log(res.data.data.cinemas) dispatch({ type:\"change-list\", payload:res.data.data.cinemas }) }).catch(err=>{ console.log(err); }) } } export default getCinemaListAction 防止重复订阅！！ // 会导致订阅多次,订阅完成之后会返回一个函数，这个函数就可以取消订阅 var unsubscribe =store.subscribe(()=>{ console.log(\"cinema中订阅\",store.getState().CinemaListReducer.cinemaList) setCinemaList(store.getState().CinemaListReducer.cinemaList) }) //禁止重复订阅 return(()=>{ //取消订阅 unsubscribe() }) b. redux-promise 1.安装redux-thunk npm i redux-promise 2.store.js中使用 import reduxPromise from 'redux-promise' const store = createStore(reducer,applyMiddleware(reduxThunk,reduxPromise)); 3.构造action时候使用-actionCreator es6写法 return(promise对象(.then)) return axios({ url:\"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159\", method:\"get\", headers:{ 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.2.1\",\"e\":\"1660142019135536282959873\",\"bc\":\"110100\"}', 'X-Host': 'mall.film-ticket.cinema.list' } }).then(res=>{ // console.log(res.data.data.cinemas) return({ type:\"change-list\", payload:res.data.data.cinemas }) }).catch(err=>{ console.log(err); }) es7写法 async和await async function getCinemaListAction(){ var list = await axios({ url:\"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159\", method:\"get\", headers:{ 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.2.1\",\"e\":\"1660142019135536282959873\",\"bc\":\"110100\"}', 'X-Host': 'mall.film-ticket.cinema.list' } }).then(res=>{ // console.log(res.data.data.cinemas) return({ type:\"change-list\", payload:res.data.data.cinemas }) }).catch(err=>{ console.log(err); }) return list // } } 7.redux调试工具 插件下载地址 https://github.com/zalmoxisus/redux-devtools-extension/releases 相关文档 https://github.com/zalmoxisus/redux-devtools-extension 安装：下载对应程序扩展到扩展程序安装即可 修改createStore部分代码如下 增 const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; 修 const store = createStore(reducer, /* preloadedState, */ composeEnhancers( applyMiddleware(reduxThunk,reduxPromise) )); 十四.react-redux 1.介绍 2.react-redux使用 1.修改index.js文件内容，外层套上react-redux Provider //引入 import { Provider } from \"react-redux\"; import store from \"./06-react-redux/redux/store\"; //使用 root.render( ); 2.订阅位置使用connect包装 //引入 import {connect} from 'react-redux' //包装 export default connect((state)=>{ console.log(state) return{ isShow:state.TabbarReducer.show } })(App) //使用 return ( {/* 其他内容 */} {this.props.isShow&&} ) connect 第一个参数，给孩子传的属性，第二个参数为给孩子传的回调函数 3.修改dispatch部分 //引入 import { show,hide } from '../redux/actionCreator/TabbarActionCreator' import {connect} from 'react-redux' //包装 //connect 第一个参数，给孩子传的属性，第二个参数为给孩子传的回调函数 export default connect(null,{ show, hide })(Detail) //使用 function Detail(props) { // console.log(props.match.params.myid,\"利用id取后端拿数据\") // console.log(props.location.query.id,\"利用id取后端拿数据\" let {show,hide,location} = props useEffect(()=>{ console.log(location.state.id,\"利用id取后端拿数据\") //store.dispatch 通知 // store.dispatch(hide()) hide() return(()=>{ // store.dispatch(show()) show() }) },[location.state.id,show,hide]) return ( Detail ) } 可优化部分 //订阅 const mapStateToProps = (state)=>{ console.log(state) return{ isShow:state.TabbarReducer.show } } export default connect(mapStateToProps)(App) //发布 const mapDispatchToProps = { show, hide } export default connect(null,mapDispatchToProps)(Detail) 3.react-redux原理 HOC与context通信再react-redux底层中的应用 connect是HOC，高阶组件 Provider组件，可以让容器组件拿到state，使用了context 高阶组件构建与应用 HOC不仅仅是一个方法，确切说应该是一个组件工厂，获取低阶组件，生成高阶组件。 代码复用，代码模块化 增删改props 渲染劫持 import React from 'react' import { useEffect } from 'react' function NotFound(props) { useEffect(()=>{ console.log(props) },[props]) return ( 404 NotFound ) } function WeiShanconnect(cb,obj){ var value= cb() return(MyComponent)=>{ return(props)=>{ console.log(props) return } } } export default WeiShanconnect(()=>{ return{ a:1, b:2 } },{aa(){console.log(\"aa\")} })(NotFound) 4.redux持久化 安装插件 redux-persist ！配合react-redux使用 npm i redux-persist 使用：改造store.js import { createStore, applyMiddleware, compose } from 'redux'; // 2.createStore(reducer) import { combineReducers } from \"redux\"; import reduxThunk from 'redux-thunk' import reduxPromise from 'redux-promise' import CityReducer from \"./reducers/CityReducer\"; import TabbarReducer from \"./reducers/TabbarReducer\"; import CinemaListReducer from \"./reducers/CinemaListReducer\"; import { persistStore, persistReducer } from 'redux-persist' import storage from 'redux-persist/lib/storage' // defaults to localStorage for web const persistConfig = { key: 'root', storage, whitelist:['CityReducer'] } const reducer = combineReducers({ CityReducer, TabbarReducer, CinemaListReducer }) const persistedReducer = persistReducer(persistConfig, reducer) const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose; const store = createStore(persistedReducer, /* preloadedState, */ composeEnhancers( applyMiddleware(reduxThunk,reduxPromise) )); let persistor = persistStore(store) // 3.导出 export {store,persistor} 改造index.js //引入 import {store,persistor} from \"./06-react-redux/redux/store\"; import { PersistGate } from 'redux-persist/integration/react' //使用 十四、UI组件库 Ant Design是一个致力于提升[用户]和[设计者]是哦那个体验的设计语言：为了统一中台项目的前端UI设计，屏蔽不必要的设计差异和实现成本，解放设计和前端研发资源；包含很多设计原则和配套的组件库。 1.ant-design(PC端) https://ant.design/index.cn https://ant-design.gitee.io/index.cn（镜像库，快） 2.antd-mobie（移动端） https://mobile.ant.design/zh 国内镜像 http://ant-design-mobile.antgroup.com/zh 3.基本使用（PC端） 安装 npm i antd 在index.js中引入样式，这样可以全局使用 import 'antd/dist/antd.min.css'; 引入组件并根据文档设置对应参数 import { Button } from 'antd'; { console.log(\"click\") } }>Primary Button 3.基本使用（移动端） 安装 npm i --save antd-mobile@next 使用 //引入(不用单独引入css!区别pc端) import {Button} from 'antd-mobile' //使用 Solid !!!!! 格式化快捷键 alt + shift + f !!!!!! 十五.Immutable 1.Immutable.js介绍 https://github.com/immutable-js/immutable.js 每一次修改一个Immutable对象时都会创建一个新的不可变的对象，在新对象上操作并不会影响到原对象的数据。 这个库实现的是深拷贝还是浅拷贝？ 2.深拷贝与浅拷贝的关系 (1)var arr = {}; arr2 = arr; (2)Object.assign()只是一级属性复制，比浅拷贝多拷贝了一层 (3)const obj1 = JSON.parse(JSON.stringify(obj));数组，对象都好用的方法(缺点：不能有undefined) //引用复制,浅复制 var obj = { name:\"WweiShan\" } var obj2 = obj obj2.name = \"WeiShanCopy\" console.log(obj,obj2) //比深复制多复制了一层，不是严格意义的深复制 var myobj = { name:\"WeiShan\", arr:[1,2,3] } var myobj2 = {...myobj} //slice等方法 myobj2.name = \"WeiShanCoppy\" myobj2.arr.splice(1,1) console.log(myobj,myobj2) //json-parse json-stringify -深复制- 致命缺点，对象中不能有undefine(会删掉) var jsonobj = { name:\"WeiShan\", arr:[1,2,3] } var jsonobj2 = JSON.parse(JSON.stringify(jsonobj)) jsonobj2.name = \"WeiShanCoppy\" jsonobj2.arr.splice(1,1) console.log(jsonobj,jsonobj2) //deepcopy 递归深复制 - 一层一层复制，性能不好，占用内存 3.Immutable优化性能的方式 Immutable实现的原理是Persistent Data Structure(持久化数据结构)，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免deepCopy把所有节点都复制一遍带来的性能损耗，Immutable使用了，Structural Sharing(结构共享),即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。 4.Immutable中常用类型(Map,List) 1.map(对象使用) 下载 npm i immutable 引入,使用(简单结构) import {map} from 'immutable' var obj = { name:\"WeiShan\", age:18 } var oldImmuObj = Map(obj) var newImmuObj = oldImmuObj.set(\"name\",\"copyWeiShan\") // console.log(oldImmuObj,newImmuObj) //1.get获取immutable console.log(oldImmuObj.get(\"name\"),newImmuObj.get(\"name\")) //2.immutable===>普通对象 console.log(oldImmuObj.toJS(),newImmuObj.toJS()) 使用(复杂使用) state = { info:Map( { name:\"WeiShan\", select:\"aa\", //需要多层加map filter:Map({ text:\"\", up:true, down:false }) } ) } componentDidMount(){ console.log(this.state.info.get(\"filter\")) } 应用(scu) //孩子scu shouldComponentUpdate(nextProps, nextState) { if(this.props.filter === nextProps.filter){ return false } return true } 2.List(数组使用) 基本使用(封装与原来数组方法一样同名) import React, { Component } from 'react' import {List} from 'immutable' var arr = List([1,2,3]) var arr2 = arr.push(4) //push不会影响老的对象结构 var arr3 = arr2.concat([5,6,7]) //不会影响之前的 console.log(arr.toJS(),arr2,arr3) export default class App extends Component { state = { favor:List( [\"aaa\",\"bbb\",\"ccc\"] ) } render() { return ( {this.state.favor.map(item=>{item})} ) } } 5.immutable高阶使用 使用 fromJS 处理复杂数据结构 //引入 import {fromJS} from 'immutable' //数据处理 state = { info:fromJS( { name:\"WeiShan\", location:{ province:\"辽宁\", city:\"大连\" }, favor:[\"读书\",\"看报\",\"写代码\"] } ) } //修改多层map this.setState({ info:this.state.info.set(\"name\",\"copyWeiShan\") .setIn([\"location\",\"city\"],\"沈阳\") }) //修改数组对象 undateIn(传入数组--多层的话[favor],第二个为回调函数，传入形参并对形参数组做处理) this.setState({ info:this.state.info.updateIn( [\"favor\"],(list)=>list.splice(index,1) ) }) 6.immutable-redux 第一种方法 const TabbarReducer = (prevState=fromJS({ show:true }),action)=>{ // let newState = {...prevState} switch(action.type){ case \"hide-tabbar\": return prevState.set(\"show\",false) case \"show-tabbar\": return prevState.set(\"show\",true) default: return prevState } } export default TabbarReducer 第二种方法 const CityReducer = (prevState={ // show:true, cityName:\"北京\" },action)=>{ let newState = fromJS(prevState) switch(action.type){ case \"change-city\": // newState.cityName = action.payload return newState.set(\"cityName\",action.payload).toJS() default: return prevState } } export default CityReducer 十六、Mobx https://cn.mobx.js.org/ 1.Mobx介绍 (1)Mobx是一个功能强大，上手非常容易的状态管理工具 (2)Mobx背后的哲学很简单 *任何源自应用状态的东西都应该自动地获得。 (3)Mobx利用getter和setter来收集组件地数据依赖关系，从而在数据发生变化地时候精确知道哪些组件需要重绘，在界面地规模变大的时候，往往会有很多细粒度更新。(vue类似) 2.Mobx与redux的区别 Mobx写法上更偏向于OOP 对一份数据直接进行修改操作，不需要始终返回一个新的数据 并非单一store，可以多个store Redux默认以JavaScript原生对象形式存储数据，而Mobx使用可观察对象 优点： a.学习成本小 b.面向对象编成，而且对TS友好 缺点： a.过于自由：Mobx提供的约定及模板代码很少，代码编写很自由，如果不做一些约定，比较容易导致团队代码风格不统一 b.相关的中间件很少，逻辑层业务整合是问题。 3.Mobx使用 （1）observable和autorun import {observable,autorun} from 'mobx' //对于普通类型数据监听 .box()方法 var observableNumber = observable.box(10) var observableName = observable.box(\"WeiShan\") observableNumber.set(20) //第一次执行一次，之后每次改变执行（有条件，只有相关的会自动执行） autorun(()=>{ console.log(observableNumber.get()) }) //加map var myObj = observable.map({ name:\"WeiShan\", age:100 }) autorun(()=>{ console.log(\"对象name属性改变\",myObj.get(\"name\")) }) //不加map var myObj1 = observable({ name:\"WeiShan\", age:100 }) autorun(()=>{ console.log(\"对象name属性改变\",myObj1.name) }) (2)mobx-action，runInAction和严格模式 方便统一在store中处理 第一种写法 import {observable,configure, action} from 'mobx' configure({ enforceActions:\"always\" }) //严格模式，必须写action //如果是never，可以不写action //最好设置always，防止任意地方修改值，降低不确定性 const store = observable( { isTabbarShow:true, list:[], cityName:\"北京\", changeShow(){ this.isTabbarShow = true }, changeHide(){ this.isTabbarShow = false } },{ changeHide:action, changeShow:action //标记两个方法是action，专门修改可观测的value } ) export default store 第二种写法 修饰器写法 @ class Store{ @observable isTabbarShow = true @observable list = [] @action changeShow(){ this.isTabbarShow = true } @action changeHide(){ this.isTabbarShow = false } } const store = new Store() export default store runInAction 处理异步 @action async getList(){ var list = await axios({ url:\"https://m.maizuo.com/gateway?cityId=110100&ticketFlag=1&k=7406159\", method:\"get\", headers:{ 'X-Client-Info': '{\"a\":\"3000\",\"ch\":\"1002\",\"v\":\"5.2.1\",\"e\":\"1660142019135536282959873\",\"bc\":\"110100\"}', 'X-Host': 'mall.film-ticket.cinema.list' } }).then(res=>{ // console.log(res.data.data.cinemas) return res.data.data.cinemas }).catch(err=>{ console.log(err); }) runInAction(()=>{ this.list = list }) } 取消订阅 var unsubscribe = autorun(()=>{ console.log(store.list,store.isTabbarShow) setCinemaList(store.list) }) return()=>{ unsubscribe() } 5.支持装饰器 npm i @babel/core @babel/plugin-proposal-decorators @babel/preset-env 创建.babelrc { \"presets\": [ \"@babel/preset-env\" ], \"plugins\": [ [ \"@babel/plugin-proposal-decorators\", { \"legacy\": true } ] ] } 创建config-overrides.js const path = require('path') const { override, addDecoratorsLegacy } = require('customize-cra') function resolve(dir) { return path.join(__dirname, dir) } const customize = () => (config, env) => { config.resolve.alias['@'] = resolve('src') if (env === 'production') { config.externals = { 'react': 'React', 'react-dom': 'ReactDOM' } } return config }; module.exports = override(addDecoratorsLegacy(), customize()) 安装依赖 npm i customize-cra react-app-rewired 修改package.json ... \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-app-rewired eject\" }, ... 学成之后关于vite "},"pages/html/HTML+CSS.html":{"url":"pages/html/HTML+CSS.html","title":"页面布局","keywords":"","body":"CSS+HTML 1.flex：1 即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。 2.dl标签相关 3.行内标签与块级标签 {/* 1.行级标签 */} {/* 1.1特点 */} {/* 可以和其他元素保持在同一行,不可以自动换行,但不能设置宽高 行内标签（内联标签）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度，高度，对齐等属性，常用于控制页面中文本的样式 */} 和相邻行内标签在一行上 高、宽无效，但水平方向的padding，margin可以设置，垂直方向的无效 行内标签只能容纳文本或者其他行内标签(a特殊 ，a标签里面可以放块级元素) {/* 1.2常见行级标签 */} {/* 下划线 */} {/* 强调 */} {/* 斜体 */} {/* 下标 */} {/* 上标 */} {/* 2.块级标签 */} {/* 2.1特点 */} {/* 不可以和其他元素保持在同一行(独占一行)，可以自动换行，能设置宽高 */} 总是从新行开始 高度、行高、外边距以及内边距都可以控制 宽度默认是容器的100% 可以容纳内联标签和其他标签 {/* 2.2常见块级标签 */} {/* 定义列表，跟ul...li类似 */} {/* 定义列表中的项目 */} {/* 3.行内块级标签 */} {/* 3.1特点 */} {/* 可以和其他元素保持在一行，还能设置宽高 */} 和相邻行内标签（或者行内块）在一行上，但是之间有空白缝隙 默认宽度就是它本身内容的宽度 块、行内标签转换为行内块：display:inline-block; {/* 3.2常见行内块级标签 */} 3.弹性布局flex 任何一个容器都可以指定为Flex布局。 .box{ display: flex; } 行内元素也可以使用Flex布局。 .box{ display: inline-flex; } Webkit内核的浏览器，必须加上-webkit前缀。 .box{ display: -webkit-flex; /* Safari */ display: flex; } 注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 一.容器的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.1.flex-direction属性 flex-direction属性决定主轴的方向（即项目的排列方向）。 .box { flex-direction: row | row-reverse | column | column-reverse; } 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 1.2.flex-wrap属性 默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } 它可能取三个值。 （1）nowrap（默认）：不换行。 （2）wrap：换行，第一行在上方。 （3）wrap-reverse：换行，第一行在下方。 1.3.flex-flow flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: ; } 1.4.justify-content属性 justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 (1)flex-start（默认值）：左对齐 (2)flex-end：右对齐 (3)center： 居中 (4)space-between：两端对齐，项目之间的间隔都相等。 (5)space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 1.5.align-items属性 align-items属性定义项目在交叉轴上如何对齐。 .box { align-items: flex-start | flex-end | center | baseline | stretch; } 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 1.6.align-content属性 align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 二.项目的属性 以下6个属性设置在项目上。 order flex-grow flex-shrink flex-basis flex align-self 2.1.order属性 https://blog.csdn.net/m0_48958478/article/details/125508280 4. 事件冒泡与事件捕获（stopPropagation 与 preventDefault ？） 事件是怎样流动的 在说stopPropagation是什么之前，需要简单说一下浏览器中的事件分发[1]。所谓事件分发机制指的是事件是怎样在DOM树中传递的。这里不得不提一下浏览器的发展历史。 初，网络世界一片混沌，一个名叫Netscape的浏览器横空出世，成为了网络世界早期真正意义上的领航者。Netscape为浏览器的发展做出了很多贡献，其很多功能后来成为了浏览器的标准。其中就包括本文所要探讨的事件模型。 对于事件传递机制，Netscape给出了自己的答案，从上往下传，即一个事件发生之后，会从文档的根一直传递到目标元素，也就是window -> document -> html -> body -> ... -> target 的传递方向。这种传递模型，也就是现在所谓的事件捕获。 有利益的地方就会有竞争。为了争夺浏览器份额，微软也开始着手浏览器的开发，推出了Netscape的最大竞争对手，IE浏览器。或许是为了显得与Netscape不一样，又或许是微软有自己的考虑，在事件传递机制上，微软的答案与Netscape截然相反，从下往上传，即一个事件发生之后，会从目标元素向上传递，一直传递的根元素，也就是 target -> parent -> ... -> body -> html -> document -> window 的传递方向。这种传递模型，也就是现在的事件冒泡。 对于攻城略地阶段的浏览器厂家来说，标准不统一还可以接受，但却苦了一众开发者。后来，Netscape日渐式微，IE独领风骚，w3c开始收拾这种混乱的局面，为事件传递机制定了一个统一的标准，浏览器既要实现事件捕获，也要实现事件冒泡。其实w3c制定这种标准也是不得已而为之，是一种兼容原Netscape页面的举动，毕竟，尽管Netscape倒了，Netscape里运行的页面还在，开发者还在。这一标准也就慢慢发展成了现在浏览器的通用标准。 事件流动模型 既然w3c制定了标准，那么正常情况下，事件的传递方向就已经是固定的了，即window -> document -> html -> body -> ... -> target -> ... -> body -> html -> document -> window的一个循环。按照这种逻辑，我们每设置一个监听器，在一次事件传递过程中，都将被触发两次，但事实真的如此吗？我们看下面的代码。 C document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷') }) document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲') }) document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }); 按照上面的推测，我们点击C元素时，事件的流动如下（为简化，去掉了无关元素）: 爷爷 -> 父亲 -> 儿子 -> 父亲 -> 爷爷 那么理应的输出也应该是 'clicked 爷爷' 'clicked 父亲' 'clicked 儿子' 'clicked 父亲' 'clicked 爷爷' 可是实际运行一下，我们得到的却是 'clicked 儿子' 'clicked 父亲' 'clicked 爷爷' 发生了什么？细心的同学可能已经发现了，捕获阶段的事件似乎没有被触发。没错，正是如此。答案就隐藏在addEventListener[2]这个方法中。 简单的来说，该方法还支持第三个参数，可以是一个对象或者boolean值，当为boolean值时，该方法的签名为 target.addEventListener(type, listener, useCapture); 当useCapture=true时，意味着事件监听器将在捕获阶段被触发，而useCapture=false时，事件监听器将在冒泡阶段触发。useCapture默认为false。 了解了这一点，再回头看前面的输出，答案就一目了然。我们所写的监听器默认是冒泡阶段触发，所以在捕获阶段的事件没有触发监听器。 如此，我们改一下监听器的触发时机，将其设为捕获阶段触发 document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷') }, true) document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲') }, true) document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }, true); --------------output-------------- clicked 爷爷 clicked 父亲 clicked 儿子 正如我们预期的按照捕获阶段的流动顺序输出了。如果想要监听到全阶段的事件传递，也很简单，只需在捕获阶段和冒泡阶段分别监听即可。 // 捕获阶段 document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷'); }, true) document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲') }, true) document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }, true); // 冒泡阶段 document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }); document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲') }) document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷'); }) --------------output-------------- clicked 爷爷 clicked 父亲 clicked 儿子 clicked 儿子 clicked 父亲 clicked 爷爷 至此，我们对事件的流动与addEventListener的具体作用有了一个清晰的了解，只有了解这些，我们才能真正明白stopPropagation的作用。 stopPropagation究竟是干嘛用的 明白了事件传递机制之后，我们就可以来探讨一下stopPropagation了。 stopPropagation，顾名思义，是用来阻止事件传递的。那么，stopPropagation阻止的究竟是捕获阶段的传递还是冒泡阶段的传递呢？ 答案就是：阻止的是整个事件传递过程中，该节点之后的事件传递。也就是说，stopPropagation阻止的并不单单是捕获阶段或者冒泡阶段，它针对的是整个事件传递过程，即包括了事件捕获以及事件冒泡。 依然是上面的代码，我们在捕获阶段调用stopPropagation。 // 捕获阶段 document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷'); e.stopPropagation(); }, true) document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲') }, true) document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }, true); // 冒泡阶段 document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }); document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲') }) document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷'); }) --------------output-------------- clicked 爷爷 可以看到，在捕获阶段，事件传递到爷爷节点时，由于调用了stopPropagation，事件就此中断，接下来的监听器以及冒泡阶段的监听器都不会再触发。因此输出只输出了‘爷爷’。 同样的，在冒泡阶段调用stopPropagation。 // 捕获阶段 document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷'); }, true) document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲') }, true) document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }, true); // 冒泡阶段 document.getElementById('儿子').addEventListener('click', (e) => { console.log('clicked 儿子'); }); document.getElementById('父亲').addEventListener('click', (e) => { console.log('clicked 父亲'); e.stopPropagation(); }) document.getElementById('爷爷').addEventListener('click', (e) => { console.log('clicked 爷爷'); }) --------------output-------------- clicked 爷爷 clicked 父亲 clicked 儿子 clicked 儿子 clicked 父亲 捕获阶段的事件顺利的接收到了，只有爷爷节点的事件没有传递到，符合预期。 至此，我们对事件传递相关的机制有了更深的了解，也对stopPropagation的真正作用有了直观印象。但是事情还没有完，还记得stopPropagation的好伙伴吗，没错，就是preventDefault。它究竟又是干嘛的呢？ preventDefault与stopPropagation有什么相关性吗 答案是没有。 很多人总是一起使用这两个方法，糊里糊涂的认为这两个方法必定有什么关联性。实际上preventDefault与stopPropagation描述的是完全不同的两种行为，他们之间的区别比java与javascript之间的区别还要大。 stopPropagation如之前所述，作用是阻止事件传递。而preventDefault的作用则是阻止默认行为。 那么什么叫默认行为？ 实际上，用语言精确的描述默认行为是一件很难的事情，不像事件模型那样，默认行为这个概念不够精准，它更偏向于人类日常交流的思维。比如一个a标签，带有一个href属性，点击之后会跳转到该href对应的网址，这就是a标签的默认行为。 方便描述，我们可以用“Element + Event = Action”的格式描述默认行为。而preventDefault的作用就是阻止这种Event所触发的“Action”。 对于a标签来说，可以描述为“a元素 + click事件 = 跳转”。preventDefault之后就成了“a元素 + click事件 = void”。跳转行为被阻止了，因此无法正常的跳转到对应的网址。 默认行为非常之多，不同的元素对应不同的默认行为。比如： \"input + keypress = 输入\"，preventDefault之后，按下键盘则无法在input里输入。 \"document + contextmenu = 弹出右键菜单\"，preventDefault之后，将无法再使用右键弹出菜单。 ... 总之，默认行为是一个很杂的事情，不需要一一记住，只要了解了preventDefault的真正作用，在写一些代码的时候才会如鱼得水，细节了然于胸，对出现的一些问题也会不再迷茫。 今天从事件模型机制与函数api上探索了事件流动相关的知识，顺便介绍了preventDefault这个方法的真正含义。这些方法平时广泛被使用，却很少有人真正接触其原理。工作并不一定是一件让人愉悦的事情，但平时的积累最终会沉淀为自己内在的高度。多总结，多思考，知其然，更要知其所以然，在前端这个行业，也在自己的人生道路上，走的越来越远吧。 "},"pages/html/JAVASCRIPT.html":{"url":"pages/html/JAVASCRIPT.html","title":"javascript","keywords":"","body":"JavaScript相关知识点 1.《学习JavaScript数据结构与算法》 1.http-serve - js服务器,http-serve打开指定的端口访问 2.undefined - 声明变量未赋值 3. 1==\"1\" 对的 toNumber(\"1\") = 1 1==1 1===1 对的 4.delete运算符 5.js中的false undefined null NaN +0 -0 长度为0的字符串 false 6.对象始终为true new Biilean(false) - true new String('') - true new Number(NaN) - true {} - true 7.当使用 == 做比较时候会按照下表进行转换后比较 例子： console.log('packt'==true) ? 输出为false 字符串与布尔比较，字符串转为数字再比，数字与字符串比较，字符串转为数组再比，则toNumber(true) = 1 , toNumber('packt') = NaN 1 != NaN , 所以结果为false，其余的也做同类型表 关于 toPrimitive js的内部函数 - 数组就是对象 对象转原始类型会调用内置的[toPrimitive]函数，该函数逻辑如下： 如果已经原始类型，就不需要转换 调用x.valueOf()，如果转换为基础类型，就返回转换的值 调用x.toString()，如果转换为基础类型，就返回转换的值 如果没有返回原始类型，就会报错 什么时候使用？ - 对象类型与字符串或者数字比较的时候 值得注意的是： NaN不等于NaN NaN也不等于undefined 使用isNaN判断 Number(b.toString())==Number(b.toString()) - 也返回false 8.当使用 === 判断时候，类型不相同直接返回false 值得注意的是：两个对象比较时候，两个引用同一个对象的时候才true，不同对象但相同结构仍为false(指针相关)，引用类型；--数组也是如此 9.面向对象编程时，对象是类的实例 10.js中函数原型只有一个形参时，传两个实参不会报错 11.什么时候用while什么时候用for？ 知道执行次数的时候一般用for，条件循环时一般用while。 12.关于函数原型 - prototype 使用函数原型定义函数时，函数只会被创建一次，直接定义则每个实例都会创建自己的函数副本。使用原型节约内存 原型 proto（隐式原型）与prototype（显式原型，也叫原型对象） ①.是什么 显式原型：每一个函数在创建之后都会拥有一个名为prototype的属性，这个属性指向函数的原型对象。 隐式原型：JavaScript中任意对象都有一个内置属性[[prototype]]，在ES5之前没有标准的方法访问这个内置属性，但是大多数浏览器都支持通过proto来访问。ES5中有了对于这个内置属性标准的Get方法 Object.getPrototypeOf(). Object.prototype 这个对象是个例外，它的proto值为null ②.两者的关系和作用 关系：隐式原型指向创建这个对象的函数(constructor)的prototype 作用： 显式原型的作用：用来实现基于原型的继承与属性的共享。 隐式原型的作用：构成原型链，同样用于实现基于原型的继承。举个例子，当我们访问obj这个对象中的x属性时，如果在obj中找不到，那么就会沿着__proto__依次查找。 ③.图解 首先，要明确几个点： (1).在JS里，万物皆对象。 方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。 即：对象具有属性proto，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。 (2).方法(Function) 方法这个特殊的对象，除了和其他对象一样有上述proto属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。 原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。constructor属性用来测试对象的类型，除此之外，就不要使用。同时，原型对象的proto指向Object.prototype 知道了这两个基本点，我们来看看上面这副图。 1).构造函数Foo() 构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。 2).原型对象Foo.prototype Foo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。 3).实例 f1和f2是Foo这个对象的两个实例，这两个对象也有属性 proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。 另外： 构造函数Foo()除了是方法，也是对象啊，它也有 proto 属性，指向谁呢？ 指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的 proto指向了Function.prototype。 其实除了Foo()，Function(), Object()也是一样的道理。 原型对象也是对象啊，它的 proto属性，又指向谁呢？ 同理，指向它的构造函数的原型对象呗。这里是Object.prototype. 最后，Object.prototype的 proto属性指向null。 总结： 对象有属性 proto ,指向该对象的构造函数的原型对象。 方法除了有属性 proto,还有属性prototype，prototype指向该方法的原型对象。 13.关于js调试工具部分 ctrl+shift+I 14.JS中map()方法！！ map定义和方法 map()方法返回一个新数组，数组中的元素为原始数组元素调用函数处理的后值。 map()方法按照原始数组元素顺序依次处理元素。 map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 var array1 = [1,4,9,16]; const map1 = array1.map(x => x *2); console.log(map1); 15.深拷贝浅拷贝 ①.概念 深拷贝与浅拷贝在其它语言中也经常被提及到，因为它们分别对应着值拷贝与引用拷贝。 深拷贝：从字面上的意思理解，是指很深的拷贝，到底有多深呢？深到不仅拷贝值，而且还独立开辟了一个空间。我的理解是：拷贝的过程中，独立地开辟了一个空间，这个对象指向这个地址，与原来的对象互不干扰。深拷贝也被称为值拷贝。 浅拷贝：从字面上的意思理解，是指比较浅的拷贝，它与原来的变量仍然指向同一个地址，两者之间相互影响，即其中一个改变会影响另一个的改变。浅拷贝也被称为引用拷贝，引用的意思就是取了个别名，例如张三是大名，狗蛋是他的引用，即为小名，张三变了，狗蛋自然也变了，因为他们本质上就是指同一个人 ②.js中的深拷贝(值拷贝) js中的基本数据类型：String Number Boolean Null Undefined，在赋值的过程中都是值拷贝. 例如，let a = 10 ; b = a , 修改其中一个变量的值，不会影响到另一个变量的值 ③.js中的浅拷贝(引用拷贝) js中的对象数据类型：Object Array Function Map Set，在赋值过程中都是引用拷贝(指向同一个地址，相当于一个房间多了一个钥匙) ④.将浅拷贝装换为深拷贝 Array深拷贝几种方法 -- slice()方法 ， concat方法 ， ES6语法中使用[...arr] , Array.from方法 Object的深拷贝 -- Object.assign() ， 万能转换器JSON.parse(JSON.stringify(obj)) ， 1）Array的深拷贝 slice方法 slice()操作数组时，不会对原数组有影响，会产出一个新的数组。 let arr1 = [1, 42, 5, 6] let arr2 = arr1.slice() arr2[0] = 100 console.log(arr1) // [1, 42, 5, 6] console.log(arr2) // [100, 42, 5, 6] 数组arr2的改变未引起arr1的变化 concat()方法 数组的concat()方法，能够连接两个数组，同样不会改变原来的数组。用一个空数组连接另一个数组，即可实现深拷贝。 let arr3 = ['cat', 'dog', 'pig'] let arr4 = [].concat(arr3) arr3[2] = 'big pig' console.log(arr3) // ['cat', 'dog', 'big pig'] console.log(arr4) // ['cat', 'dog', 'pig'] ES6语法中 ... ES6语法中的 …， 我经常在数组的深拷贝中用到。 let arr5 = [0, 0, 1] let arr6 = [...arr5] arr5[0] = 10000 console.log(arr5) // [10000, 0, 1] console.log(arr6) // [0, 0, 1] 2）Object的深拷贝 Object.assign()方法 ES6的Object.assign() Object.assign(target, …sources)用于对象的合并，将源对象中的所有可枚举属性，复制到目标对象中，并返回合并后的目标对象。后来的源对象的属性值，将会覆盖它之前的对象的属性。 let person = { name: 'xia', age: 25, height: 160 } let otherPerson = Object.assign({}, person) person.age = 30 console.log(person) console.log(otherPerson) 万能转换器（对Array和Object等都适用） 前面讲解了 Array和Object的深拷贝方法，但是对于有更深层次的结构关系（数组套数组 数组套对象 对象套对象等），上面的方法就失灵了，可以看下面的例子。 let personArr = [{name: 'xia'}, {name: 'zhang'}] let otherPersonArr2 = [...personArr] personArr[0].name = 'xia xia' console.log(personArr) console.log(otherPersonArr2) 万能转换器 JSON.parse(JSON.stringify(obj))深拷贝已有对象，它可以深拷贝多层级的，不用担心嵌套问题。 JSON.stringfy() 将对象序列化成json对象 JSON.parse() 反序列化——将json对象反序列化成js对象 JSON.stingify(obj)将js中的对象转换成JSON字符串 let jack = { name: 'jack' } console.log(jack) console.log(JSON.stringify(jack)) 它们在格式上有区别。下图中的第一个是对象，name没有双引号括起来。第二个是json字符串，其中，name用双引号括起来了 JSON.parse()将json字符串解析成对象 let obj = { name: '静茹秋叶' } console.log('obj: ', obj) console.log('json string: ', JSON.stringify(obj)) let str = JSON.stringify(obj) console.log('--------------') console.log(str) console.log('str to obj: ', JSON.parse(str)) 16.JS关于promise ECMAscript 6 原生提供了promise对象 Promise对象代表了未来将要发生的事件，用来传递异步操作的消息 ①概述 Promise是异步编程的一种解决方案，可以代替传统的解决方案--回调函数和事件。ES6统一了用法，并原生提供了Promise对象。作为对象，Promise有一下两个特点： 1)对象的状态不受外界影响。 2)一旦状态改变了就不会在变，也就是说任何时候Promise都只有一种状态 ②Promise的状态 17.JS箭头函数 箭头函数都是匿名函数 普通函数可以是匿名函数 // 具名函数 function func(){ // code } // 匿名函数 let func=function(){ // code } // 箭头函数全都是匿名函数 let func=()=>{ // code } 箭头函数不能用于构造函数，不能使用new 普通函数可以用于构造函数吗，从此创建对象实例 function Person(name,age){ this.name=name; this.age=age; } let admin=new Person(\"恩诺小弦\",18); console.log(admin.name); console.log(admin.age); 箭头函数中的this的指向不同 普通函数中this总是指向调用它的对象，如果用作构造函数，this指向创建的对象实例。 箭头函数没有自己的this，它的this是继承而来，默认指向在定义它时所处的对象(宿主对象)。 其他区别 箭头函数不能Generator函数，不能使用yeild关键字。 我们可以理解yield是一个暂停动作，这个暂停动作可以接受上一步的结果作为参数，也可以额将这一阶段执行的结果返回给外部。上面整个做菜过程，是可以临时掺杂其他的事情的，这就是yield的最大作用。 了解了yield之后，更能理解generator的存在意义。实际上它和promise一样，是用来解决函数异步调用的。 箭头函数不具有prototype原型对象。 箭头函数不具有super。 *super 方法 super作为函数调用时，代表父类的构造函数。 ES6 要求，子类的构造函数必须执行一次super函数。子类B的构造函数之中的super()，代表调用父类的构造函数。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例，因此super()在这里相当于A.prototype.constructor.call(this)。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 *super 对象 super作为对象时，在普通方法中，指向父类的原型对象，在静态方法中，指向父类。 由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例。由于this指向子类实例，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象。在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。 箭头函数不具有new.target。 new.target允许你检测函数或构造方法是否是通过new运算符调用的，若函数或构造方法是由new调用的，则new.target属性的值指向该函数或构造函数，否则值为undefined。 总结： 箭头函数的 this 永远指向其上下文的 this ，任何方法都改变不了其指向，如 call() , bind() , apply() 普通函数的this指向调用它的那个对象 18.匿名函数的应用 1.绑定事件 //javascript var btn=document.querySelector(\"#btn\"); //querySelector是H5中新增的查找dom元素的方法 btn.οnclick=function(){ alert(\"\"); } 2.应用对象 var obj={ animal:\"汤姆猫\", voice:\"喵喵喵~~\", CAT:function(){ return \"我是\"+this.animal+\"，我会\"+this.voice+\"叫！\"; } }; alert(obj.CAT()); 3.应用函数表达式 //将匿名函数赋值给变量cat var cat=function(){ return \"喵喵喵~~\" } //调用方式与调用普通函数一样 alert(cat()); 4.回调函数的应用 setInterval(function(){ console.log(\"我是每5秒执行一次的回调函数\"); },5000); 5.返回值 function cat(){ //返回匿名函数 return function(){ return \"喵喵喵~~\"; } } //调用匿名函数 alert(cat()()); //或 var mao=cat(); alert(mao()); 6.链式调用 (function(animal) { alert(animal); return arguments.callee; })('cat')('dog')('pig'); 链式调用： 例 $('text’).setStyle('color', 'red').show(); 一般的函数调用和链式调用的区别：链式调用完方法后，return this返回当前调用方法的对象。 (1)先创建一个简单的类 //创建一个bird类 function Bird(name) { this.name=name; this.run=function () { document.write(name+\" \"+\"start run;\"); } this.stopRun=function () { document.write(name+\" \"+\"start run;\"); } this.sing=function () { document.write(name+\" \"+\"start sing;\"); } this.stopSing=function () { document.write(name+\" \"+\"start stopSing;\"); } } (2)使用方式：一般的调用方式 var bird=new Bird(\"测试\"); bird.run(); birdbird.sing(); bird.stopSing(); bird.stopRun(); （3）总结，该种方式有一个弊端就是：多次重复使用一个对象变量 然后，我们再来看看将上述改成链式调用的格式 (1)在创建的简单类中加上return this，如下 //创建一个bird类 function Bird(name) { this.name=name; this.run=function () { document.write(name+\" \"+\"start run;\"); return this;// return this返回当前调用方法的对象。 } this.stopRun=function () { document.write(name+\" \"+\"start run;\"); return this; } this.sing=function () { document.write(name+\" \"+\"start sing;\"); return this; } this.stopSing=function () { document.write(name+\" \"+\"start stopSing;\"); return this; } } (2)使用链式调用（连缀的方式） var bird=new Bird(\"测试\"); bird.run().sing().stopSing().stopRun();//结果为;测试 start run;测试 start sing;测试 start stopSing;测试 start run; (3)总结此种方式的调用结果与一般的调用方式产生的结果一样，优点是：链式调用这种风格有助于简化代码的编写工作，让代码更加简洁、易读，同时也避免多次重复使用一个对象变量 19.filter使用(includes) 例:找到数组中包含a的 /** * filter 不会改变原对象 */ var arr = [\"aaa\",\"abc\",\"bcc\"] //前面为数组内元素，后面为回调方法，当返回true时候不会过滤掉此数组项 var newarr = arr.filter(item=>item.includes(\"a\")) console.log(newarr) 输出为 [\"aaa\",\"abc\"] 20.关于localStorage HTML API localstorage 在浏览器的 API 有两个：localStorage 和sessionStorage，存在于 window 对象中：localStorage 对应 window.localStorage，sessionStorage 对应 window.sessionStorage。 localStorage 和 sessionStorage 的区别主要是在于其生存期。 基本使用方法 这里的作用域指的是：如何隔离开不同页面之间的localStorage（不能在百度的页面上能读到腾讯的localStorage）。 localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。 sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。 生存期 localStorage理论上来说是永久有效的，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。但需要注意的是，在移动设备上的浏览器或各Native App用到的WebView里，localStorage都是不可靠的，可能会因为各种原因（比如说退出App、网络切换、内存不足等原因）被清空。 sessionStorage的生存期顾名思义，类似于session，只要关闭浏览器（也包括浏览器的标签页），就会被清空。由于sessionStorage的生存期太短，因此应用场景很有限，但从另一方面来看，不容易出现异常情况，比较可靠。 容量限制 目前业界基本上统一为5M，已经比cookies的4K要大很多了。 域名限制 由于浏览器的安全策略，localstorage是无法跨域的，也无法让子域名继承父域名的localstorage数据，这点跟cookies的差别还是蛮大的。 异常处理 localstorage在目前的浏览器环境来说，还不是完全稳定的，可能会出现各种各样的bug，一定要考虑好异常处理。我个人认为localstorage只是资源本地化的一种优化手段，不能因为使用localstorage就降低了程序的可用性，那种只是在console里输出点错误信息的异常处理我是绝对反对的。localstorage的异常处理一般用try/catch来捕获/处理异常。 如何测试用户当前浏览器是否支持localstorage 目前普遍的做法是检测window.localStorage是否存在，但某些浏览器存在bug，虽然\"支持\"localstorage，但在实际过程中甚至可能出现无法setItem()这样的低级bug。因此我建议，可以通过在try/catch结构里set/get一个测试数据有无出现异常来判断该浏览器是否支持localstorage 浏览器兼容性 在ios设备上无法重复setItem() 另外，在iPhone/iPad上有时设置setItem()时会出现诡异的QUOTA_EXCEEDED_ERR错误，这时一般在setItem之前，先removeItem()就ok了。 21.async、await 一、async用法 async作为一个关键字放在函数前面，用于表示函数是一个异步函数。异步函数也就意味着函数的执行不会阻塞后面代码的执行。 调用：异步函数也是函数，怎么调用函数就怎么调用它，直接加括号就可以了 async函数返回一个promise对象，如果获取到promise返回值，我们应该用then方法 你可能注意到控制台中的Promise 有一个resolved，这是async 函数内部的实现原理。如果async 函数中有返回一个值，当调用该函数时，内部会调用Promise.solve() 方法把它转化成一个promise 对象作为返回，但如果timeout 函数内部抛出错误呢？ 那么就会调用Promise.reject() 返回一个promise 对象， 这时修改一下timeout 函数 22.babel含义及作用 Babel含义： Babel 是一个 JavaScript 编译器，它能让开发者在开发过程中，直接使用各类方言（如 TS、Flow、JSX）或新的语法特性，而不需要考虑运行环境，因为 Babel 可以做到按需转换为低版本支持的代码；Babel 内部原理是将 JS 代码转换为 AST，对 AST 应用各种插件进行处理，最终输出编译后的 JS 代码。 在开发中我们在写es6+语法的时候是不是很方便，什么promise、async await`，可是es6+语法写的虽然很酸爽，但是浏览器他不兼容啊，你想想你写的代码在浏览器上跑不起来，在好的语法在好的特性又有什么用？ 这个时候Babel这样一个工具出来了，他可以将我们写的es6+语法转换为浏览器兼容的语法，比如将箭头函数转换为普通函数，有了这样一个工具我们就即可以写酸爽的语法，又可以让使浏览器兼容。 三大步骤 最常见的 @babel/preset-env 预设，包含了一组最新浏览器已支持的 ES 语法特性，并且可以通过配置目标运行环境范围，自动按需引入插件。 解析阶段：Babel 默认使用 @babel/parser 将代码转换为 AST。解析一般分为两个阶段：词法分析和语法分析。 转换阶段：Babel 使用 @babel/traverse 提供的方法对 AST 进行深度优先遍历，调用插件对关注节点的处理函数，按需对 AST 节点进行增删改操作。 生成阶段：Babel 默认使用 @babel/generator 将上一阶段处理后的 AST 转换为代码字符串。 Babel 插件系统 Babel 的核心模块 @babel/core，@babel/parser，@babel/traverse 和 @babel/generator 提供了完整的编译流程。而具体的转换逻辑需要插件来完成。 在使用 Babel 时，我们可通过配置文件指定 plugin 和 preset。而 preset 可以是 plugin 和 preset 以及其他配置的集合。Babel 会递归读取 preset，最终获取一个大的 plugins 数组，用于后续使用。 常见 presets @babel/preset-env @babel/preset-typescript @babel/preset-react 23.闭包 console.log(\"----------简单的闭包----------\") function closeFunction() { console.log(\"闭包内部\") let i = 1; function inner() { i++ console.log(i) } return inner } var f1 = closeFunction(); f1() //输出2 f1() //输出3 var f2 = closeFunction() f2() //输出2 f2() //输出3 //总结：inner函数中的i就是行程闭包的”元凶“，由于inner函数没有自己的i变量，所以会引用 // 外部作用域(closeFunction作用域)的i变量，因此当inner函数被返回后，closeFunction // 的i变量得不到释放，因为f对其有引用，因此i变量一直会在内存中，知道f=null //可以利用闭包保存函数的变量，并且外部无法直接访问到内部变量，避免定义过多全局变量 console.log(\"----------非闭包效果----------\") function simpleFunction() { console.log(\"简单函数\") let i = 1; i++; console.log(i) } simpleFunction() //输出2 simpleFunction() //输出2 console.log(\"----------非闭包应用场景----------\") 24.ES6 总结es6相关的知识点 字符串拼接 使用反引号 `` 例子： let str='我是佩奇' console.log(`你是野猪${str}`) //结果 你是野猪我是佩奇 ES6中数组新语法 map() 数组.map()也就是映射。通俗地讲就是遍历数组，且修改每一个数组元素，返回的结果是一个新的数组。举个简单的例子，假设商场打折，给每件商品打8折，其中arr数组中是所有商品的价格： let arr = [89, 50, 99, 45, 100, 30, 60, 30] console.log(arr.map(item => item * 0.8))//0:71.2 1: 40 2: 79.2 3: 36 4: 80 5: 24 6: 48 7: 24 length: 8 如果难理解的话，可以看下所示的： let arr = [89, 50, 99, 45, 100, 30, 60, 30] let newArr = arr.map((item) => { return item * 0.8 }) console.log(newArr)//0:71.2 1: 40 2: 79.2 3: 36 4: 80 5: 24 6: 48 7: 24 length: 8 2.filter() 数组.filter()是筛选数组的，将符合条件的元素放入新数组中，如果存在，返回所有满足条件的新数组，不存在，则返回空数组，且这个方法的执行次数等于数组的长度。举个简单的例子，找到数组中所有的负数： let arr1 = [12, 23, -2, 45, 2, 13, -9] console.log(arr1.filter(item => item item 3.forEach() 数组.forEach()等价于for(let i=0;i let arr = [10, 23, 41, 23, 56] arr.forEach((item, index) => { console.log(index, item)//0 10 1 23 2 41 3 23 4 56 }) 4.some() 数组.some()是用来检测数组中是否有符合条件的元素，返回的结果是布尔型，如果是true表示有符合条件的元素，如果是false则表示没有符合条件的元素，应用场景：非空判断。举个简单的例子，判断一个数组是否存在负数 let arr1 = [12, 1, 34, -2, 4] console.log(arr1.some(item => item item 5.every（） 数组.every()是用来检测是否所有的元素都满足条件，如果所有元素都满足条件，返回结果为true，反之返回false，这个思想就类似于开关思想，和some()是相反的。举例：判断数组是不是都是正数 let arr = [1, 3, 2, 5, -2, 6] console.log(arr.every(item => item > 0)) //false 6.findIndex() 数组.findIndex()是用来查找元素的，如果元素存在返回该元素的下标，如果不存在则返回-1，和indexOf作用一样，区别在于indexOf只能查找值类型的数据，而findIndex可以查找引用类型数据。举例：在数组中找李四和小明 let arr = [{ name: '张三', age: 20 }, { name: '李四', age: 50 }, { name: '王五', age: 20 } ] /* 查找李四 */ console.log(arr.findIndex(item => item.name == '李四')) //1 console.log(arr.findIndex(item => item.name == '小明')) //-1 7.reduce（） 数组.reduce()是数组累加器，对数组每一个元素执行一次回调函数，累加最后一次回调的结果，应用场景：求总价。以下面这个例子为例进行详细的讲解： let arr = [12, 34, 23, 15, 6] console.log(arr.reduce((sum, item) => { return sum + item }, 0)) //90 因为reduce()，默认下标从1开始，所以需要设置，在reduce里补0，（如果从1开始遍历，遇到空数组会报错）类似于从0下标开始遍历，同样也代表着let sum=0，每次将返回的值赋值给sum，等价于sum=sum+item，每次执行一次，返回的结果将作为下一轮sum的值，且最终返回最后一次执行的结果 关于 promise 与 异步编成问题！！ https://blog.csdn.net/qq_47443027/article/details/118763485 "},"pages/html/WEB-DIARY.html":{"url":"pages/html/WEB-DIARY.html","title":"web日记","keywords":"","body":"1.伪类、伪元素 伪类就是某个元素的一种虚拟状态，或者说一种特有的性质，这种状态或性可以通过 CSS 捕捉到，伪类是一个冒号（:）后跟伪类的名字构成的 伪元素是一种虚拟的元素，CSS 把它当成普通 HTML 元素看待。之所以叫伪元素，就因为它们在文档树或 DOM 中并不实际存在。换句话说，我们不会在 HTML 中包含伪元素，只会通过 CSS 来创建伪元素。 伪元素是一个冒号还是两个冒号？ 简单回答：多数情况下，都行。 两个冒号（::）是 CSS3 为了区分::before、::after这样的伪元素和:hover、:active等伪类才引入的。除了 IE8 及以下版本，所有浏览器都支持两个冒号的伪元素表示法。 可以使用::after清除浮动 .classic-clearfix::after { content: ''; display: block; clear: both; } 2.CSS的@media与@media screen，媒体查询 3.解决yarn安装包后，文件名、目录名或卷标语法不正确问题 原因： yarn 的全局安装位置与 bin 的位置并不一致导致的 1.先查看npm的位置 // 查看全局安装位置 npm config get prefix // E:/Tools/node/node_global // 查看缓存位置 npm config get cache // E:/Tools/node/node_cache 2.检查yarn的bin安装位置 yarn global bin 3.检查yarn的全局安装位置 yarn global dir 修改 yarn的全局安装位置试试，将其修改为与 npm 一致（顺便把缓存位置也改了） yarn config set global-folder \"E:/Tools/yarn/global\" yarn config set cache-folder \"E:/Tools/yarn/cache\" 4.小程序分包 概念 分包指的是把一个完整的小程序项目，按照需求划分为不同的子包，在构建时打包成不同的分包，用户在使用时按需进行加载。 作用 对小程序进行较好的优化 优化小程序首次启动的加载时间 多人开发的过程中可以更好的解耦 分包后的项目构成 主包：启动界面或TabBar页面，以及所有分包都需要用到的公共资源 分包：只包含和当前分包有关的页面和私有资源 小程序打包原则 小程序会按照subPackages的配置进行分包，subPackages之外的目录将会被打包到主包中 主包也可以有自己的pages tabBar页面必须在主包内 分包之间不能相互嵌套 引用原则 主包无法引用分包的私有资源 分包之间不能相互引用私有资源 分包可以引用主包内的公共资源 独立分包 独立分包本质也是分包，它特殊在可以独立于主包和其他分包而单独运行（独立于主包的分包） 它的好处在于，不依赖主包，可以提高页面启动速度 在配置层面，它和普通分包的区别仅仅是 为在分包的最后添加\"independent\":true属性 独立分包和普通分包以及主包之间的资源都是相互隔绝的 5.节流与防抖 https://blog.51cto.com/u_15899048/5902563 "},"pages/backend/BACKEND.html":{"url":"pages/backend/BACKEND.html","title":"后端","keywords":"","body":" 后端 "},"pages/backend/php/PHP.html":{"url":"pages/backend/php/PHP.html","title":"PHP","keywords":"","body":" PHP "},"pages/backend/database/DATABAESE.html":{"url":"pages/backend/database/DATABAESE.html","title":"数据库","keywords":"","body":" 数据库 "},"pages/backend/database/NOSQL.html":{"url":"pages/backend/database/NOSQL.html","title":"NoSql","keywords":"","body":" NOSQL 概念 NoSQL（NoSQL=Not Only SQL），意即“不仅仅是SQL”。 发展 NoSQL快速发展     关键原因是：传统关系型数据库遇到了性能瓶颈     高并发读写、对海量数据的高效率存储 和访问以及对数据库的高可扩展性和高可用性成了关系型数据库难以逾越的鸿沟，关系型数据库应对这三大问题显得力不从心，暴露了很多难以克服的问题，例如： 1、High performance - 对数据库高并发读写的需求 web2.0网站要根据用户个性化信息来实时生成动态页面和提供动态信息，所以基本上无法使用动态页面静态化技术，因此数据库并发负载非常高，往往要达到每秒上万次读写请求。关系数据库应付上万次SQL查询还勉强顶得住，但是应付上万次SQL写数据请求，硬盘IO就已经无法承受了。其实对于普通的BBS网站，往往也存在对高并发写请求的需求，例如像JavaEye网站的实时统计在线用户状态，记录热门帖子的点击次数，投票计数等，因此这是一个相当普遍的需求。 2、Huge Storage - 对海量数据的高效率存储和访问的需求 类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。 3、High Scalability && High Availability- 对数据库的高可扩展性和高可用性的需求 在基于web的架构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，你的数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移，为什么数据库不能通过不断的添加服务器节点来实现扩展呢？ 在上面提到的“三高”需求面前，关系数据库遇到了难以克服的障碍，而对于web2.0网站来说，关系数据库的很多主要特性却往往无用武之地，例如： ①.数据库事务一致性需求 很多web实时系统并不要求严格的数据事务，对读一致性的要求很低，有些场合对写一致性要求也不高。 ②.数据库的写实时性和读实时性需求 很多web实时系统并不要求严格的数据库事务，对读一致性的要求很低，有些场合对写一致性要求也不高。因此数据库事务管理成了数据库高负载下一个沉重的负担。 ③.对复杂的SQL查询，特别是多表关联查询的需求 任何大数据量的web系统，都非常忌讳多个大表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询，特别是SNS类型的网站，从需求以及产品设计角度，就避免了这种情况的产生。往往更多的只是单表的主键查询，以及单表的简单条件分页查询，SQL的功能被极大的弱化了。 因此，关系数据库在这些越来越多的应用场景下显得不那么合适了，为了解决这类问题的非关系数据库应运而生，现在这两年，各种各样非关系数据库，特别是键值数据库(Key-Value Store DB)风起云涌，多得让人眼花缭乱。下面，我们具体看一下它的分类： 特点 https://blog.csdn.net/jiuqiyuliang/article/details/41879145 "},"pages/backend/database/MYSQL.html":{"url":"pages/backend/database/MYSQL.html","title":"MySql","keywords":"","body":"MYSQL线上服务器部署 一.基本配置 更换默认3306线上开放端口更换为不常见的端口号。 更换默认用户名 更换默认密码 开启binlog日志文件，方便数据恢复跟数据变更查询 二.SSL认证 线上版本5.7以上 PS.虽然SSL方式使得安全性提高了，但是相对地使得QPS也降低23%左右 1.查看是否开启了ssl show global variables like '%ssl%'; //“have_ssl” 为YES的时候,数据库是开启加密连接方式的。 2.查看数据库基本信息 select version(); //查看数据库版本 show variables like 'port'; //查看数据库端口 show variables like 'datadir'; //查看数据库存放路径 3.配置证书 通过openssl制作生成证书 ①.生成一个CA私钥 openssl genrsa 2048 > ca-key.pem ②.通过CA私钥生成数字证书 openssl req -new -x509 -nodes -days 99999 -key ca-key.pem -out ca.pem ③.创建mysql服务器私钥和请求证书 openssl req -newkey rsa:2048 -days 99999 -nodes -keyout server-key.pem -out server-req.pem ④.将私钥转换为RSA私钥文件格式 openssl rsa -in server-key.pem -out server-key.pem ⑤.用CA证书生成一个服务器的数字证书 openssl x509 -req -in server-req.pem -days 99999 -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out server-cert.pem ⑥.创建客户端的RSA私钥和数字证书 openssl req -newkey rsa:2048 -days 99999 -nodes -keyout client-key.pem -out client-req.pem PS：Common Name字段需要填写应用服务器的ip或域名，也就是指连接服务器的ip（新服务器ip） ⑦.将生成的私钥转换为RAS私钥文件格式 openssl rsa -in client-key.pem -out client-key.pem ⑧.用CA证书来生成一个客户端的数字证书 openssl x509 -req -in client-req.pem -days 99999 -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out client-cert.pem PS：将生成后的客户端证书拷贝到应用服务器上，client-* 4.数据库配置ssl证书 ①.将CA证书和服务端ssl文件至mysql数据目录 cp ca.pem server-*.pem /www/server/data # /www/server/data是数据库的路径 ②.修改msql数据库目录的CA证书和服务端ssl文件所属用户和组 chown -v mysql.mysql /www/server/data{ca,server*}.pem ③.修改mysql配置文件，添加ssl调用配置 vi /etc/my.cnf 在mysqld下添加 [mysqld] ssl-ca=/www/server/data/ca.pem ssl-cert=/www/server/data/server-cert.pem ssl-key=/www/server/data/server-key.pem ④.重启mysql服务，检查数据库ssl是否开启状态,have_openssl 与 have_ssl 值都为YES表示ssl开启成功 service mysqld restart show variables like 'have%ssl%'; ⑤.测试ssl可用性 grant all on *.* to 'test'@'127.0.0.1' identified by 'test' require SSL; PS 需要将127.0.0.1更换为应用服务器的ip ⑥.密码连接测试 mysql -utest -ptest -h 127.0.0.1 此时会报错： ERROR 1045 (28000): Access denied for user 'test1'@'124.222.67.220' (using password: YES) YES代表需要密码，但没有通过ssl验证 PS 如果MySQL端口不是3306，需要在后面加参数(-P 端口号) ⑦.通过客户端密钥与证书ssl+密码连接测试，并查看属性 mysql -utest -ptest -h 127.0.0.1 --ssl-cert=client-cert.pem --ssl-key=client-key.pem 进入数据库后，\\s查看属性 加密前： SSL: Not in use 加密后： SSL: Cipher in use is DHE-RSA-AES256-GCM-SHA384 PS启动时，需要在client-cert.pem和client-key.pem证书目录下启动，或者在启动时更改证书的路径 例:mysql -utest -ptest -h 127.0.0.1 --ssl-cert=/root/client-cert.pem --ssl-key=/root/client-key.pem MYSQL储存用户密码 1.直接明文保存，比如用户设置的密码是“123456”，直接将“123456”保存在数据库中，这种是最简单的保存方式，也是最不安全的方式。但实际上不少互联网公司，都可能采取的是这种方式。 2.使用对称加密算法来保存，比如3DES、AES等算法，使用这种方式加密是可以通过解密来还原出原始密码的，当然前提条件是需要获取到密钥。不过既然大量的用户信息已经泄露了，密钥很可能也会泄露，当然可以将一般数据和密钥分开存储、分开管理，但要完全保护好密钥也是一件非常复杂的事情，所以这种方式并不是很好的方式。 3.使用MD5、SHA1等单向HASH算法保护密码，使用这些算法后，无法通过计算还原出原始密码，而且实现比较简单，因此很多互联网公司都采用这种方式保存用户密码，曾经这种方式也是比较安全的方式，但随着彩虹表技术的兴起，可以建立彩虹表进行查表破解，目前这种方式已经很不安全了。 PS.彩虹表技术 彩虹表的出现，针对性的解决了 R 函数导致的链重复问题：它在各步的运算中，并不使用统一的 R 函数，而是分别使用 R1…Rk 一共 k 个不同的 R 函数。这样生成的哈希链集即被称为彩虹表。 4.特殊的单向HASH算法，由于单向HASH算法在保护密码方面不再安全，于是有些公司在单向HASH算法基础上进行了加盐、多次HASH等扩展，这些方式可以在一定程度上增加破解难度，对于加了“固定盐”的HASH算法，需要保护“盐”不能泄露，这就会遇到“保护对称密钥”一样的问题，一旦“盐”泄露，根据“盐”重新建立彩虹表可以进行破解，对于多次HASH，也只是增加了破解的时间，并没有本质上的提升。 5.PBKDF2算法，该算法原理大致相当于在HASH算法基础上增加随机盐，并进行多次HASH运算，随机盐使得彩虹表的建表难度大幅增加，而多次HASH也使得建表和破解的难度都大幅增加。 使用PBKDF2算法时，HASH算法一般选用sha1或者sha256，随机盐的长度一般不能少于8字节，HASH次数至少也要1000次，这样安全性才足够高。一次密码验证过程进行1000次HASH运算，对服务器来说可能只需要1ms，但对于破解者来说计算成本增加了1000倍，而至少8字节随机盐，更是把建表难度提升了N个数量级，使得大批量的破解密码几乎不可行，该算法也是美国国家标准与技术研究院推荐使用的算法。 随机盐+名文密码 -> 多次hash -> 密文密码 函数定义 DK = PBKDF2(PRF, Password, Salt, c, dkLen) 其中： DK是PBKDF2算法产生的密钥 PRF是一个伪随机函数，例如HASH_HMAC函数，它会输出长度为hLen的结果 Password 是用来生成密钥的原文密码 Salt 是一系列用于生成密钥加密的盐值 c是迭代运算的次数 dkLen 是期望得到的密钥的长度 mysql,mysqli和PDO的区别 PHP-MySQL 是 PHP 操作 MySQL 资料库最原始的 Extension PHP-MySQLi 的 i 代表 Improvement ，提更了相对进阶的功能，就 Extension 而言，本身也增加了安全性。 PDO (PHP Data Object) 则是提供了一个 Abstraction Layer 来操作数据库。只需要使用PDO接口中的方法就可以对数据库进行操作 PDO配置 PHP.ini中,去掉\"extension=php_pdo.dll\"前面的\";\"号,若要连接数据库，还需要去掉与PDO相关的数据库扩展前面的\";\"号，然后重启Apache服务器即可。 extension=php_pdo.dll extension=php_pdo_mysql.dll extension=php_pdo_pgsql.dll extension=php_pdo_sqlite.dll extension=php_pdo_mssql.dll extension=php_pdo_odbc.dll extension=php_pdo_firebird.dll mysql优化 MySQL优化方向： 在设计上：字段类型，存储引擎，范式 在功能上：索引，缓存，分库分表 在架构上：集群，主从复制，负载均衡，读写分离 MySQL索引 1.索引是什么？ 索引是帮助MySQL高效获取数据的数据结构。 索引往往存储在磁盘上的文件中 索引中包括:聚集索引，覆盖索引，组合索引，前缀索引，唯一索引 等，默认都是使用B+树结构组织索引 ps.主键索引跟唯一索引的区别 主键是一种约束，唯一索引是一种索引； 主键创建后一定包含一个唯一性索引，唯一性索引不一定是主键； 唯一性索引列允许空值， 主键不允许； 主键可被其他表引为外键，唯一索引不能； 一个表只能创建一个主键，但可创建多个唯一索引。 主键更适合那些不容易改变的唯一标识，如自动递增列，身份证号等。 在RBO 模式下，主键的执行计划优先级高于唯一索引。两者可以提高查询的速度。--oracle 2.索引的优劣势？ 优势： 检索:可以提高数据检索的效率，降低数据库的IO成本 排序:通过索引列对数据进行排序，降低了CPU的消耗 劣势: 占磁盘空间 降低更新表的效率 3.索引分类 单列索引 普通索引：没有任何限制。add index 唯一索引:索引列中的值必须唯一，允许空值。add unique index 主键索引:特殊的唯一索引，不允许空值。PK 组合索引 在表中的对个字段组合上创建的索引 add index(col1, col2……) 遵循最左前缀原则(最左匹配原则) 全文索引(MyISAM,InnoDB5.6以后) 只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。fulltext 优先级最高，先执行 存储索引，决定执行一个索引 空间索引 PS.在 MySQL 中, 索引是在存储引擎层实现的, 所以并没有统一的索引标准, 由于 InnoDB 存储引擎在 MySQL数据库中使用最为广泛, 下面以 InnoDB 为例来分析一下其中的索引模型.在 InnoDB 中, 表都是根据主键顺序以索引的形式存放的, InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的，如下图所示 从图中可以看出, 根据叶子节点内容不同,索引类型分为主键索引和非主键索引. 主键索引也被称为聚簇索引,叶子节点存放的是整行数据; 而非主键索引 被称为二级索引,叶子节点存放的是主键的值. 如果根据主键查询, 只需要搜索ID这颗B+树 而如果通过非主键索引查询, 需要先搜索k索引树, 找到对应的主键, 然后再到ID索引树搜索一次, 这个过程叫做回表. 总结, 非主键索引的查询需要多扫描一颗索引树, 效率相对更低. 关于B+树 数据结构... 4.索引使用 1.索引相关语句 主键索引不需要创建，系统会自动生成 ①.单列索引之普通索引 create index index_name on table(coloumn(length)); alter table table_name add index index_name(column(length)); ②.单列索引之唯一索引 create unique index index_name on table(column(length)); alter table table_name add unique index index_name(column); ③.单列索引之全文索引 create fulltext index index_name on table(column(length)); alter table table_name add fulltext index_name(column); ④.组合索引 alter table table_name add index index_name(time(50),title(50)...); ⑤.删除索引 drop index index_name on table; ⑥.查看索引 show index from table_name; 5.索引原理分析 5.1 索引的存储结构 索引在存储引擎中实现(不同的引擎会只用不同的索引) MyISAM和InnoDB存储引擎:只支持B+tree索引 MEMORY/HEAP存储引擎:支持HSAH和BTREE索引 MyISAM采用的是非聚簇索引，InnoDB采用的是聚簇索引 ①.B树 B树的高度一般在2-4，树的高度直接影响IO读写的次数 三层树结构----支撑的数据可以达到20G,如果是四层树结构----支撑的数据可以达到几十T ②.B树和B+树的区别 B树和B+树最大区别在于非叶子节点是否存储数据的问题。 由于B树的其他子节点也存储有数据data，所以在每页中占用了相当一部分内存，而B+树只有主键索引，没有数据data域，每页((4kB,8KB,16KB)存储的主键索引相对来说是比较多的。 MySQL中的B树和B+树有什么区别？ 解析：B+树继承于B树，都限定了节点中数据数目和子节点的数目。B树所有节点都可以映射数据，B+树只有叶子节点可以映射数据。 为了B+树创造了很多冗余的索引（所有非叶子节点都是冗余索引），这些冗余索引让B+树在插入、删除的效率都更高，而且可以自动平衡，因此B+树的所有叶子节点总是在一个层级上。所以B+树可以用一条链表串联所有的叶子节点，也就是索引数据，这让B+树的范围查找和聚合运算更快。 5.2 聚集(簇)索引(InnoDb) 主键索引(聚集索引)的叶子结点会存储数据行，也就是说数据和索引在一起 辅助索引只会存储主键值 5.3 非聚集(簇)索引(MyISAM) B+树叶子结点只会存储数据行（数据文件）的指针，简单来说就是数据和索引不在一起 非聚集索引包含 主键索引 和 辅助索引 到会存储指针的值 5.4 主键索引Primary key InnoDB要求表必须有主键(MyISAM可以没有)，如果没有，MySQL系统会自动选择一个唯一标识数据记录的列作为主键 MyISAM的索引文件(mdi）仅仅保存数据记录的地址 MyISAM的数据文件(ibd)中记录对应的记录 5.5 辅助索引Secondary key(次要索引) 结构和主键搜索引没有任何区别 同样用B+Tree,data域存储相应记录主键的值而不是地址 聚集索引通过主键搜索十分高效，但是辅助索引搜索需要检索两边索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。 TODO:https://blog.csdn.net/qq_44129924/article/details/115333658 SQL优化 1.插入优化 大量数据采用批量插入形式 事务设置手动提交，MySQL默认是自动提交，意味着每写一个SQL事务就自动提交，可能会频繁的涉及事务开始和提交，所以建议手动提交 2.order dy优化 Using filesort：通过表的索引或者全表扫描，读取到满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序，所以返回的数据不是通过索引直接返回的，这样的排序形式就叫filesort Using index：通过有序索引顺序扫描直接返回有序数据，这种情况不需要额外的排序，所以效率比较高 根据多字段排序时，遵循左前缀原则 3.group by优化 group by进行分组 在分组操作时，可以通过索引来提高效率，索引使用也要满足左前缀原则 "},"pages/backend/security/SECURITY.html":{"url":"pages/backend/security/SECURITY.html","title":"安全","keywords":"","body":" 安全 "},"pages/backend/algorithms/ALGORITHMS.html":{"url":"pages/backend/algorithms/ALGORITHMS.html","title":"数据结构与算法","keywords":"","body":"数据结构与算法 "},"pages/backend/algorithms/BASEDATA.html":{"url":"pages/backend/algorithms/BASEDATA.html","title":"基础数据类型","keywords":"","body":"基础数据类型 1.队列 跟 栈 1.区别 操作名称不同入队、出队、进栈、出栈 操作方式不容队列队尾入队，队头出队。栈进栈出栈都是在栈顶进行 操作的方法不同队列是先进先出(FIFO)，即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾(不能中间插入),每次离开的成员总是队列头上(不允许中途离队)。而栈为后进先出(LIFO),即每次删除(出栈pop)的总是当前栈最新的元素，即最后插入（进栈push）的元素，而最先插入的被放在栈的底部，最后才能删除。 2.栈的应用 顺序栈 #define MAXSIZE (100) //栈的最大存储数据量 typedef struct STACK { int data[MAXSIZE]; //用于存储数据的数组 int top; //栈顶指针 }SqStack; 顺序栈的进栈操作： 检查是否满栈，满栈退出并返回错误 栈顶指针top向上移动一位，将要插入的数据赋给栈顶 顺序栈的出栈操作： 检查是否为空栈，若是则退出并返回错误； 将栈顶数据赋给*data(函数参数的传递必须要用到指针的，c++最好使用引用)，栈顶指针向下移动一位。 链栈 线性表有顺序存储和链式存储结构，栈是一种特殊的线性表，那么也有链式存储结构，简称链栈。 将链表的头指针作为栈的栈顶指针，因为有栈顶指针，就不需要链表的头结点了。 typedef struct StackNode //结点 { int data; struct StackNode *next; }StackNode; typedef struct LinkStack //栈顶指针和结点数 { StackNode *top; int count; }LinkStack; 链栈进栈操作： 申请一个新结点，储存进栈数据； 将新结点插入到链表的最前端，使其next指向原先的top结点，最后使top指向新结点； 链栈出栈操作： 检查是否为空栈，若是返回错误，否则将栈顶指针指向的数据赋给*data； 删除栈顶结点：定义一个指针p，指向栈顶结点，将栈顶指针top指向下一个结点，删除栈顶结点。 顺序栈的链栈的时间复杂度是一样的，都是O(1)，如果栈内元素数量变化小且可控，可以使用顺序栈，链栈因为每个结点都有指针域，增加了一定内存的开销；如果栈内的元素数量不可控，最好使用链表，根据实际需求变化长度，不会造成大量空间浪费。 应用 大多数的编译器递归操作基于栈实现的 四则运算表达式：从左到右遍历中缀表达式的每个数组跟符号，若是数字就输出成为后缀表达式（有名逆波兰表达式，所有符号都要在运算附后的后面出现）的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号(乘除优先加减)则栈顶元素依次出栈并输出，并当前符号进栈，移植到最终输出后缀表达式为止； 中缀到后缀的转换 3.队列的应用 2.链表 链表是一种物理存储结构上非连续、非顺序的储存结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。 "},"pages/backend/COMMUNICATION-PROTOCOL.html":{"url":"pages/backend/COMMUNICATION-PROTOCOL.html","title":"通信协议","keywords":"","body":"通信协议 一、网络分层架构 二、TCP和UDP协议 1.UDP协议 UDP（user Datagram Protocol）:用户报文协议 没有任何特点 和TCP对比：不可靠、无连接、面向报文 1.UDP作为一种简单的传输层协议，基本上没有什么操作来帮助用户处理复杂的网络环境，所以UDP保留下来这种不可靠的特性。 2.UDP报文的头信息(定长的(8字节)) 3.校验和（checksum）的作用和工作机制 判断收到的报文(数据)是否出现差错的 利用hash函数的原理：通过设计一种hash函数，达到冲突率很低的一种情况 发送端:checksum(payload)=>校验和1（把校验和1填写到UDP的header中） 接收端:checksum(payload)=>校验和2 比较校验和2和header中的校验和1：如果不等，payload在传输过程中一定出现差错了；如果相等，大概率payload没有出现出错 针对校验和可以对上的情况，正常接收数据。 针对校验和对不上的情况，直接丢包；UDP不是特别可靠 4.UDP协议栈的作用 计算校验和 填写正确的header信息 把header + payload一起交给网络层(重点：UDP没有*发送缓冲区) 网络层发送数据到网卡 send方法返回 重点：我们在应用层调用send方法时方法返回了，就*意味着数据已经到达了网络层中 接收到数据后 计算校验和 解包 通知指定的进程，数据已经到达...这段期间，进程可能还暂时来不及过来取数据。所以UDP协议栈需要找个地方把数据暂存一会儿。UDP协议栈中有接收缓冲区。 5.UDP有接收缓冲区，没有发送缓冲区 用戶发送多少数据，UDP也会发送多少数据，所以UDP是面向报文的 UDP发送数据无需任何准备工作，随时随地可以发送：寄件VS打电话，所以UDP是无链接的 6.面向报文导致的一个后果 由于底层(物理层+网络层)都对一次发送的数据大小限制。如果强行发送大于限制的数据，就会出现数据被截断 全双工：同一个通道是双向的 7.UDP协议的最适合场景 对实时性要求较高、对可靠性要求较低的场景 实时聊天(语音、视频聊天) UDP支持广播。如果有广播需求可以考虑UDP。 2.TCP协议 TCP(Transmission Control Protocol):传输控制协议 1.目标 以进程为单位传递数据 追求可靠性 2.什么是可靠性 TCP只能保证自己最大的可能，把数据有序地发送给对方。但不能保证一定发送给对方 尽可能去发送给对方 就算发不过去，也有反馈 保证对方接收是有序的 保证对方不会收到差错数据 TC会设计一些机制，来尽可能的优化网络，提高对方收到的可能性 TCP使用什么样的机制，来保证可靠性 -- 确认应答机制 TCP发送的数据，一般被称为segment(数据段) 应答：acknowledge 如果发送方同时发送了多条segment，应答进行了多次应答。发送方如何得知，接收方收到的是那一次的segment? 编号机制：发送方为发送的数据做编号，应答的时候带上对应编号即可。 如果接收方没有收到数据，则不会应答；或者接收方应答了。但应答丢包了 总之：发送方没有收到对应的应答。则认为对方没有收到数据 -- 超时重传机制 3.TCP协议的header格式 和UDP不同，TCP的header不是定长的。 哪个或者哪些字段，可以保证接收方的TCP协议栈进行解包工作？ 4位的header长度 根据源port+目标port做分用 到目前为止，TCP发送的segment有两种：（1.携带数据segment 2.应答 segment），TCP协议并没有把两种作用的segment进行不同格式的设计，而是进行统一的设置了！ 那具体怎么区分本次segment是否具有应答的作用呢？ ack == 1时segment有应答功能；ack==0时segment没有应答功能 segment的可能情况(1)光携带数据；(2)携带数据+应答(网络中合并数据发送，可以提高网络发送的效率) 32位序号：SN(sequence Number) 32位确认序号：ASN(AckNowledge Sequence Number) 4.SN和ASN书写规则 TCP为发送每个字节都进行编号(只是payload，没有header) [h e l l o] h:108(随便选的)，e:109 ，l:110 ，l:111 ，0:112 TCP协议栈在建立链接时，会随机一个初识序列号(Initial Sequence Number ISN)ISN:108 发送的时候，header中的SN填写的是payload中的第一个字节的序列号 [hello] SN:108 接收方是知道长度是5的，所以，接收方如果收到数据，则表示108-112已经全部收到了 ASN应该如何填写？填写的是接收方期望收到的下一个字节的数据 上述例子中，接收方要应答的话ASN应该填写113。隐含的意思就是113之前的所有数据，已经全部接收到了。 如果发送方超过一定时间都没有收到应答，则可能 发送方的处理逻辑是一致的。超时之后，直接重传即可(重传的数据不会丢失)，不需要区分情况 6 . 如果乱序到达怎么办？ 对于发送方，收到了一个应答segASN=x时，发送方是怎么理解这个信号的？ 对方已经收到收到了x-1之前的所有数据了。 TCP协议是有接收缓冲区的，保证对方接收是有序的(接收端可以重新整理数据，接收过得数据不再接收) 如果超时之后，重传对方仍然没有收到，怎么办？ 继续重传，直到到达一个阈值（假设6次）。如果6次，我都没有收到应答。我就认为不需要再努力的，放弃： 尽人事，试图通知对方，链接异常关闭了---通过发送一个reset segment(另一种)。 rst = 1，reset segment rst = 0，不是reset segment 通过我们的应用层，数据发送失败了。(Java中是通过异常的方式通知的，会收到一个IOException(SocketException)描述reset connection) 5.链接管理（Connection Message） 为什么需要链接（链接是什么抽象）? 作为TCP协议栈，是需要维护一个接受缓冲区的。 ①.保证整理乱序到达的数据 ②.在数据暂时未被应用层读走之前，临时保存数据 作为TCP协议栈，是需要维护一个发送缓冲区的。 因为要考虑重发的可能性，所以未应答的数据不能直接扔掉，所以需要一个空间暂存 例：send(\"hello\")成功，代表数据被发送到OS的TCP协议栈的发送缓冲区中 作为TCP协议栈 发送方时，需要维护已经发送的SN 接收方时，需要维护应该应答的SN 上述3点，足以说明：TCP协议栈，为了保证之前的那些机制可用，必须为每个信道，维护一组相关的数据！！ 6.建立连接的必要性 由于TCP是追求可靠的，所以TCP在正式发送之前，想验证下对象是否能收到我的数据。 类比:寄信 + 电话 Connection对象，有一部分信息是无法独立知道的，需要双方进行有效信息的同步 TCP的建立链接，需要双方交换几次信息---三次---三次握手 [为什么是三次？] TCP是需要保证可靠性的，所以，任意数据(除了应带，reset)都需要进行应答 (2)、(3) 事实上，总是可以同时发送的，为了提升网络利用率，所以合并(2)、(3) 四种segment:数据segment、应答segment(ack=1)、reset segment(rst=1)、同步segment(syn=1) 1. 什么是链接，为什么TCP需要有链接，UDP就没有链接。 逻辑上对信道的抽象。物理上各自内存中维护的信道相关的一组数据。 因为TCP为了追求可靠性引入一系列机制（确认应答机制，超时重传机制），为了这些机制能正常的工作，是的TCP必须引入链接的概念。 2. 建立链接阶段的必要性 互相确认对象在线 双方同步必要的初识信息 3. 为什么要三次握手 三、域名解析及为什么选用UDP协议 1.DNS是什么？ DNS ( Domain Name Systme)简单理解就是解析器、域名服务器的组合，比如大家访问知乎，会输入http://www.zhihu.com，事实上网站域名只是一个IP 地址，人们是很难记住各式各样的IP地址的，所以就需要DNS服务器了， DNS 就像手机通讯录一样，存放着各亲朋好友的手机号。为什么要存储到通讯录里？因为你不可能记得一百个人的手机号码，但是通过名字你可以快速定位某位朋友的手机号码。DNS就是存储了各种IP地址，然后让你通过域名定位到IP地址来进行连接通信的。 DNS主要作用就是将主机域名转换为ip地址 所有DNS请求和回答报文使用的UDP数据报经过端口53发送 DNS是应用层协议，client端（一般指游览器）构建DNS查询请求，一次被传入传输层，网络层，数据链路层等封装传送到达DNS服务器端，最终client端接收到DNS响应消息 为什么选择UDP UDP（User Datagram Protocol）这样的无连接的，尽最大能力交付的不可靠数据连接，而不是使用TCP(Transmission Control Protocol 传输控制协议)这样的面向连接的可靠数据连接。 一次UDP名字服务器交换可以短到两个包：一个查询包、一个响应包。一次TCP交换则至少包含9个包：三次握手初始化TCP会话、一个查询包、一个响应包以及四次分手的包交换。 考虑到效率原因，TCP连接的开销大得，故采用UDP作为DNS的运输层协议，这也将导致只有13个根域名服务器的结果。 为什么只有 13 个根服务器？ 这是由于本地 DNS 基础设施的限制，它使用的是 32 字节 IPv4，IP 地址必须对应一个数据包，当时数据包限制为 512 字节，所以每个IPv4地址是32位，其中13位是416字节，剩下的96字节是协议信息; 根域名服务器用来管理互联网的主目录，是DNS中最高级别的服务器，返回顶级域的权威域名服务器地址； 2.因特网的域名结构 因特网的域名结构: 因特网采用了层次树状结构的命名方法。 任何一个链接在因特网的主机或者路由器，都有一个唯一的层次结构的名字，即域名。 域名的结构由标号序列组成，各标号之间用点隔开: 域名服务器： 一个域名服务器所负责管辖的(或有权限的)范围叫做区(zone)。 各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。 每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。 DNS 服务器的管辖范围不是以“域”为单位，而是以“区”为单位。 域名只是逻辑概念，并不代表计算机所在的物理地点。顶级域名TLD(Top Level Domain)分为三大类： 国家顶级域名nTLD：采用ISO3166的规定。如：cn代表中国，us代表美国，uk代表英国，等等。国家域名又常记为ccTLD(cc表示国家代码contry-code)。 通用顶级域名gTLD：最常见的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营利组织)，int(国际组织)，gov(美国的政府部门)，mil(美国的军事部门)。 基础结构域名(infrastructure domain)：这种顶级域名只有一个，即arpa，用于反向域名解析，因此称为反向域名。 域名服务器有以下四种类型： 根域名服务器 根域名服务器是最重要的域名服务器。所有的根域名服务器都知道所有的顶级域名服务器的域名和 IP 地址。 不管是哪一个本地域名服务器，若要对因特网上任何一个域名进行解析只要自己无法解析，就首先求助于根域名服务器。 在因特网上共有13个不同 IP 地址的根域名服务器，它们的名字是用一个英文字母命名，从a 一直到 m（前13 个字母） 根域名服务器并不直接把域名直接转换成 IP 地址。 在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的 IP 地址告诉本地域名服务器。 顶级域名服务器 这些域名服务器负责管理在该顶级域名服务器注册的所有二级域名。 当收到 DNS 查询请求时，就给出相应的回答（可能是最后的结果，也可能是下一步应当找的域名服务器的 IP 地址） 权限域名服务器 本地域名服务器 3.缓存(Cache) DNS缓存：每次你访问网站，DNS会保存你访问过的网站的域名服务器（即DNS) 信息，它存储在你的本机电脑上，目的就是为了帮助你下次在浏览器以最短的路径、更快的速度找到所需的DNS信息，解析你的网站！ 缓存具体分类： 浏览器缓存 当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）； 系统缓存 当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP； 4.DNS请求实例 http://news.sohu.com/a/529566154_657867 "},"pages/backend/DOCKER.html":{"url":"pages/backend/DOCKER.html","title":"docker","keywords":"","body":"关于容器docker 1.为什么会出现     软件开发部署需要重复的在不同的操作系统或者不同的环境下搭建同样的环境，环境搭建需要添加各种依赖，可能还需要配置各种环境变量。希望能 安装的时候，把原始环境一模一样地复制过来。 1、虚拟机 虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，虽然可以通过虚拟机还原软件原始环境，但是这个方案有一下几个缺点： 资源占用多：虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有1MB，虚拟机依然需要几百MB的内存才能运行。 冗余步骤多：虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。 启动慢:启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。 2、Linux容器 https://baijiahao.baidu.com/s?id=1694108417119974229&wfr=spider&for=pc "},"pages/backend/MESSAGE-QUEUE.html":{"url":"pages/backend/MESSAGE-QUEUE.html","title":"消息队列","keywords":"","body":" 消息队列-message queue 一、消息队列概述 消息队列中间件是分布式系统中重要的组件，主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。目前使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ 二、消息队列的应用场景 2.1异步处理 场景说明：用户注册后，需要发注册邮件和注册短信。传统的做法有两种 1.串行的方式；2.并行方式 a、串行方式：将注册信息写入数据库成功后，发送注册邮件，再发送注册短信。以上三个任务全部完成后，返回给客户端。 b、并行方式：将注册信息写入数据库成功后，发送注册邮件的同时，发送注册短信。以上三个任务完成后，返回给客户端。与串行的差别是，并行的方式可以提高处理的时间 "},"pages/server/SERVER.html":{"url":"pages/server/SERVER.html","title":"服务器","keywords":"","body":" 服务器 "},"pages/server/CDN.html":{"url":"pages/server/CDN.html","title":"CDN","keywords":"","body":"CDN 什么是CDN？ CDN的全程是Content Delivery NetWork，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡，内容分发，调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 CDN原理 以腾讯云为例，假设业务源站域名为 www.test.com ， 域名接入CDN开始使用加速服务后，当用户发起HTTP请求时，实际的处理流程如下图: CDN作用 CDN缓存内容后，用户仅需访问就近的CDN节点即可获取静态内容。 环节源站带宽压力，网络费用更低。 分布全球的跨境节点提升跨境访问体验。 网站域名接入CDN 开通CDN服务器后，配置域名信息(域名必须备案) 静态文件加速选CDN网页小文件 进行源站配置 (“回源协议”设置的是HTTPS需要进行配置证书) 配置完成之后进行CNAME配置(域名解析加上对应的记录值) CDN防御配置 CDN作为按量付费的产品，防止用户 盗刷 产生大量带宽或者流量 防御盗刷流量或者遭遇CC、DDOS等攻击，需要进行配置防御 1.用量封顶配置 如果超出了配置的访问阈值，就可以自动关闭 CDN 服务，或者请求直接返回源站，有两种配置方式： 带宽封顶 流量封顶 2.防盗链配置与黑白名单配置 可以进行黑白名单配置来防止盗刷 3.IP访问频率配置 通过对单 IP 单节点在每一秒钟的访问次数进行限制，可进行高频 CC 攻击抵御、防恶意用户盗刷等。 4.安全加速SCDN 腾讯云安全加速SCDN为预付费产品，集成了Web 攻击防护、DDoS防护、CC防护等多项安全功能，可以更加全面地提升加速网络的安全防护能力。 5.服务器的面板进行流量控制 什么是CDN边缘服务器 CDN 边缘服务器是存在于网络逻辑极端或“边缘”的计算机。边缘服务器常用作不同网络之间的链接。CDN边缘服务器的主要目的是将内容存储在尽可能 靠近发出请求的客户端机器的位置 ，从而 减少延迟并缩短页面加载时间。 边缘服务器是一种边缘设备，可提供进入网络的入口点。其他边缘设备包括路由器和路由交换机。边缘设备通常防止在Internet交换点(IxP)内，以允许不同的网络连接和共享传输。 边缘服务器怎么工作的？ 在任何特定的网络布局中，许多不同的设备将使用一种或多种预定义的网络模式相互连接。 如果网络想要连接到另一个网络或更大的 Internet，它必须具有某种形式的桥接器，以便流量从一个位置流向另一个位置。 在网络边缘创建此桥的硬件设备称为边缘设备。 网络通过边缘设备链接 在连接了许多设备的典型家庭网络中，移动电话或计算机等设备通过中心辐射型网络模型连接或者断开网络。在所有设备都存在于同一个局域网中(LAN)，每个设备都连接到一个中央路由器，通过它们可以相互连接。 为了将第二个网络连接到第一个网络，在某些时候必须在网络之间建立链接。根据定义，网络能够通过其相互连接的设备是边缘设备。 CDN提供商会将服务器放置在许多位置，但其中一些最重要的是不同网络之间边缘的连接点。这些边缘服务器将多个不同的网络连接，并允许流量在网络之间快速有效地传递。如果没有CDN，传输可能会在源和目的地之间采用更慢和/或更复杂的路线。在最坏的情况下，流量将“长号”远距离；当服务器连接到街对面的另一台设备时，连接可能会在全国范围内移动并再此返回。通过在关键位置边缘服务器，CDN能够快速向不同网络内的用户交付内容。 边缘服务器与源服务器的区别     源服务器是在web资产中使用CDN时接收所有Internet流量的web服务器。使用没有CDN的源服务器意味着每个Internet请求都必须返回到该源服务器的物理位置，而不敢它位于世界的那个位置。这回增加加载时间，这回增加服务器与发出请求的客户端机器的距离。     CDN边缘服务器在战略位置存储(缓存)内容，以便减轻一个或者多个源服务器的负载。通过将图像、HTML和JavaScript文件(以及可能的其他内容)等静态资产尽可能靠近发出请求的客户端机器，边缘服务器缓存能够减少加载WEB资源所需时间。源服务器在使用CDN时仍然发挥着重要的作用，因为重要的服务器端代码(例如用于身份验证的散列客户端凭据数据库)通常在源端维护。 CDN与对象存储的关系 对象存储的核心是存储，以及计算能力(图片处理)，cdn的核心是分发，本身不会给用户提供直接操作储存的入口，所以两者配合使用。 百度云对象存储于CDN配合使用图 对象存储：鱼与熊掌兼得的存储方式 对象存储将数据通道(需要访问的数据)和控制通路(云数据，即索引)分离，先根据索引(也就是元数据)找到数据存储的位置，进行通过底层的存储接口来访问数据。 通过这种方式，对象存储既有类似块存取性能，也有类似文件存储的共享便利，可谓是鱼和熊掌兼得的存储方式，对象存储主要用来存储图片、音频、视频等非结构化数据。 CDN：让用户离数据更近一点 CDN(Content Delivery Network)是内容分发网络。基本思路就是在网络各处部署服务器节点，系统实时地根据网络流量、负载状况、服务器节点到用户的响应时间等信息，自动将用户请求到导向离用户最近的节点上。目的就是让用户就近取得数据，提高响应速度。 CDN的关键技术 内容发布：借助于索引、缓存、流分裂、组播等技术，将内容发布或投递到距离用户最近的服务器节点； 内容路由：整体性的网络负载均衡技术，通过内容路由器中的重定向机制，在多个服务器节点上均衡用户的请求； 内容交换：根据内容、服务器节点以及用户的信息，利用应用层交换、流分裂等技术，智能地平衡负载流量； 性能管理：通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能。 CDN本质上是一个分布式缓存系统，每个服务器节点上都缓存了源站的一部分数据，也就是用户最近经常访问的数据访问的数据。这样大部分用户请求其实都是在CDN边缘节点上完成，并没有达到源站，这样减少了响应时间，也减轻了源站的负担，可以实现高流量、大并发的网站访问。 "},"pages/tools/TOOLS.html":{"url":"pages/tools/TOOLS.html","title":"工具","keywords":"","body":" 工具 "},"pages/tools/GIT.html":{"url":"pages/tools/GIT.html","title":"Git","keywords":"","body":"GIT 一、Github使用 访问github官网 https://github.com/ 注册账号并登陆 若访问或下载的时候慢打不开使用vpn (插件2有免费节点) 搜索资源(https://blog.csdn.net/luanfenlian0992/article/details/105684367) 常用的搜索命令： ①.直接搜索需要找的资源名称 ②.在开源项目的名称中去搜索 -- in:name XXX ③.再进一步，通过项目的stars数来缩小搜索范围 -- in:name XXX stars:>数字 ④.在项目的 README 即详细介绍中搜索关键字 -- in:readme XXX(stars:>数字 forks:>数字) ⑤.在描述(description：)中搜索关键字,同时限定使用的语言（language：） in:description XXX language:XXX ⑥.搜索范围加上项目更新的时间 in:description XXX language:XXX pushed:>时间 4.新建仓库 二、Git使用 1.git下载 https://git-scm.com/downloads 2.免密链接远程仓库 ①.生成秘钥 -- 命令之后三次enter ②.去对应文件夹复制秘钥后粘贴到github setting > ssh and GPG keys 3.安装时候可以选择编辑器 4.使用 ①.不在编辑器内使用:找到对应的文件夹然后右击git bush here 设置配置文件 - 用户名 git config --global user.name \"echo-lxq\" - 邮箱地址 git config --global user.email echo_lxq@163.com - 默认分支 git config --global init.defaultBranch main - 解决windows下使用与linux换行区别导致代码导入导出有问题 -git config --global core.autocrlf false     core.autocrlf是git中负责处理line ending的变量，可以设置3个值：true，false，inout 1.当设置成false时，line endings将不做转换操作。文本文件保持原来的样子。2.设置为input时，添加文件git仓库时，git把crlf(回车换行)编程lf(换行)。当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置； 3.当设置成true时，这意味着你在任何时候添加(add)文件到git仓库时，git都会视为它是一个文本文件(text file)。它将把crlf变成LF。 -git config --global core.safecrlf true git config --global core.safecrlf true #拒绝提交包含混合换行符的文件 git config --global core.safecrlf false #允许提交包含混合换行符的文件 git config --global core.safecrlf warn #提交包含混合换行符的文件时给出警告 PS.windows : CRLF( 回车换行 \\r\\n ) Linux/Unix: LF (换行 \\n) Mac: LF(现在是换行, 以前是回车( Classic Mac )CR, \\r ) 初始化 - git init 克隆仓库 - git clone [url] [folder] 更新仓库内容 - git add -u 将项目中修改的部分放到缓存区 -git add . 将当前文件夹内所有内容 -git commit -m [description] 设置本地提交备注 -git remote add [name] [address] 将git address命名为name -git push [name] [origin] 提交更新 后面的是选择远程仓库的分支 ②.在编辑器内使用 -- 直接输入对应命令行即可 5.分支合并问题与使用的基本思路 假设有两个分支 A 、B A 分支需要合并 B 分支新开发的代码 目前常见的主要有两种合并方式 整体合并：首先切换到A分支， （1）执行命令：git branch -a 查看当前所有分支。 执行结果： 结果分析：白色代表本地已有分支；绿色代表本地正在使用的分支；红色代表远程所有分支； （2）执行切换分支命令：git checkout A ，切换到分支A； （3）执行命令：git pull ，更新代码到最新； （4）执行命令：git merge B, 此命令的作用就是合并分支 B 上边的全量代码到分支 A； （5）切换回分支A：git checkout A （6）用开发工具打开查看合并后分支A的代码，有冲突则解决。 部分合并：首先切换到A分支， （1）执行命令：git branch -a 查看当前所有分支。 执行结果： 结果分析：白色代表本地已有分支；绿色代表本地正在使用的分支；红色代表远程所有分支； （2）执行切换分支命令：git checkout A ，切换到分支A； （3）执行命令：git pull ，更新代码到最新； （4）执行命令：git checkout B, 切换到分支 B； （5）查看分支 B 的提交记录,执行命令：git log 执行结果： 根据上述的执行结果，我们可以看到B分支的提交记录，我们选择想要合并的某一个提交记录所涉及到的内容。假设我们要合 并 配置 swagger 的内容，我们拿到上述截图中的对应的 commitid ：9af181504738a9cc52248dc2c09c19394cd480b8 （5）切换回分支A：git checkout A （6）合并 B 分支 commitid 为 9af181504738a9cc52248dc2c09c19394cd480b8 的内容， 执行命令 ：git cherry-pick 9af181504738a9cc52248dc2c09c19394cd480b8 。 （7）执行命令：git push 。将合并后的内容提交到远程仓库 三、遇到的问题及解决方法 error: Your local changes to the following files would be overwritten by merge 解决方案 根据是否要保存本地修改，有以下两种解决方案 ①.保留修改 执行以下三条命令 git stash #封存修改 git pull origin master git stash pop #把修改还原 注： git stash：备份当前工作区内容，从最近的一次提交中读取相关内容，让工作区保证和上次提交的内容一致。同时，将当前工作区内容保存到Git栈中 git pull：拉取服务器上当前分支代码 git stash pop：从Git栈中读取最近一次保存的内容，恢复工作区相关内容。同时，用户可能进行多次stash操作，需要保证后stash的最先被取到，所以用栈（先进后出）来管理；pop取栈顶的内容并恢复 git stash list：显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。 git stash clear：清空Git栈 ②.废弃修改 核心思想就是版本回退，具体命令如下 git reset --hard git pull origin master 注：不建议使用第二种。除非你再三确定不需要本地的修改了。 "},"pages/tools/VSCODE-CONFIG.html":{"url":"pages/tools/VSCODE-CONFIG.html","title":"VsCode","keywords":"","body":"VSCODE配置 一、颜色及代码配置 1 vscode主题选择为 Solarized Light 2 自定义颜色部分(setting.json) \"workbench.colorTheme\": \"Solarized Light\", \"workbench.colorCustomizations\": { \"editor.selectionBackground\": \"#e41fda7e\", //选中高亮 \"editor.background\": \"#C7EDCC\", //背景颜色 }, \"editor.tokenColorCustomizations\":{ \"comments\": \"#9ea023da\", //注释 \"keywords\": \"#0a0\", // 关键字 \"variables\": \"#f00\", // 变量名 \"strings\": \"#18170fbd\", // 字符串 \"functions\": \"#5b99fcc9\", // 函数名 \"numbers\": \"#AE81FF\" // 数字 }, 3 自定义字体大小与取消逗号补全关键字 \"ecitor.fontsize\":16, \"editor.acceptSuggestionOnCommitCharacter\": false, 二、html快捷键配置 1.快速生成标签 打开配置文件添加如下配置 \"emmet.triggerExpansionOnTab\": true, \"emmet.showAbbreviationSuggestions\": true, \"emmet.showExpandedAbbreviation\": \"always\", \"emmet.includeLanguages\": { \"javascript\": \"html\" } 三、JS快捷键配置 1.快速头注释 安装 koroFileHeader 配置 setting.json 在VS Code中，依次打开 “文件(File) → 首选项(Preferences) → 设置(Settings)”,然后搜索fileheader以打开setting.json文件 最后在setting.json中添加如下配置命令：（配置命令可自定义修改哈，详细配置见GitHub：koroFileHeader） // 头部注释 \"fileheader.customMade\": { //快捷键 ctrl+win+i \"Author\": \"Xminyang\", // 创建文件的作者 \"Date\": \"Do not edit\", // 文件创建时间(不变) \"LastEditors\": \"Xminyang\", // 文件最后编辑者 // 由于编辑文件就会变更最后编辑时间，多人协作中合并的时候会导致merge // 可以将时间颗粒度改为周、或者月，这样冲突就减少很多。搜索变更时间格式: dateFormat \"LastEditTime\": \"Do not edit\", // 文件最后编辑时间 // 输出相对路径，类似: /文件夹名称/src/index.js \"FilePath\": \"Do not edit\", // 文件在项目中的相对路径 自动更新 // 插件会自动将光标移动到Description选项中 方便输入 Description字段可以在specialOptions更改 \"Description\": \"\", // 介绍文件的作用、文件的入参、出参。 // custom_string_obkoro1~custom_string_obkoro100都可以输出自定义信息 // 可以设置多条自定义信息 设置个性签名、留下QQ、微信联系方式、输入空行等 \"custom_string_obkoro1\": \"\", // 版权声明 保留文件所有权利 自动替换年份 \"custom_string_obkoro1_copyright\": \"Copyright (c) ${now_year} by 用户/公司名, All Rights Reserved. \" }, // 函数注释 \"fileheader.cursorMode\": {//快捷键 ctrl+win+t \"description\": \"\", // 函数注释生成之后，光标移动到这里 \"param\": \"\", // param 开启函数参数自动提取 需要将光标放在函数行或者函数上方的空白行 \"return\": \"\", } 四、react配置 1.快捷键插件配置 组件名 - VS Code ES7 React/Redux/React-Native/JS snippets 快捷键 - 输入rcc + 回车 = 生成类组件必要代码 五、代码语法规则配置-ESlint 1.插件安装 ESLint 2.插件扩展配置 添加如下配置： \"editor.codeActionsOnSave\": { \"source.fixAll.eslint\":true }, 3.配置 eslint 进行格式化 由于安装最新的 create-react-app 结合 VScode 编辑器即可支持 eslit，但是需要在项目根目录中要添加 .env 这个配置文件，设置 EXTEND_ESLINT=true 这样才会启用 eslint 检测，注意要 重启 vscode "},"pages/tools/VITE.html":{"url":"pages/tools/VITE.html","title":"Vite","keywords":"","body":"VITE 使用vite代替官方create-react-app 特点:快-创建过程、更新过程、启动过程跟webpack两条路 官方文档：https://vitejs.cn/ code . //在命令行中输入可以使用vscode打开当前命令行路径文件 "},"pages/tools/PHPSTORM.html":{"url":"pages/tools/PHPSTORM.html","title":"PhpStorm","keywords":"","body":"高效实用phpstorm 1.TODO 学会利用TODO，可以标记你以后有待修改的代码，当团队协作的时候，也起到了告诉其他人需要维护的部分的作用，它的作用就是记录你的待办事宜，在注释中加 TODO 即可，想查看所有的待办事宜，Alt+6就好。 2.前端代码快捷键 前端代码响应标签 加上 tab 可以快速生成代码 -- 类似于webstorm ！+ tab 可以快速生成头文件块 .class + tab 可以快速生成带class 的div标签 3.依赖工具 依赖工具，例如你使用的版本管理工具SVN或者GIT，也可以在PhpStorm中配置，在File中的Settings，Version Control版本控制，Git对应Git，SVN对应Subversion，里面的路径分别写git与svn的exe路径。 4.使用问题 当你的PhpStorm机器占用缓慢，或者当你开着PhpStorm但是电脑变慢的时候，可以 File里面的invalidate caches/restart重启应用，清除缓存，可以提高效率。 "}}